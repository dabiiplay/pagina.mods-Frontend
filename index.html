<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Página Mods</title> <!-- Título cambiado a "Página Mods" -->
    <!-- Favicon: Sube tu imagen "diamond_pickaxe.png" a la raíz de tu repositorio de GitHub. -->
    <!-- Si el icono está en la misma carpeta que index.html, usa una ruta relativa como esta: -->
    <link rel="icon" href="./diamondpickaxe.png" type="image/png">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: "Inter", sans-serif;
            overflow: hidden; /* Prevent body scroll */
            background-color: #1a202c; /* Dark bluish gray for body */
        }
        /* Custom styles for draggable/resizable elements */
        .element-wrapper { /* This is the new wrapper for draggable elements */
            position: absolute;
            cursor: grab;
            user-select: none;
            box-sizing: border-box;
            transition: box-shadow 0.1s ease-in-out; /* Smooth transition for shadow */
            will-change: transform, left, top; /* Added for rendering optimization */
        }
        .element-wrapper.selected {
            box-shadow: 0 0 0 2px #8B5CF6; /* Purple shadow when selected, always opaque */
            cursor: grabbing;
        }

        /* NEW: Styles for text element wrappers (applied conditionally by JS) */
        .text-element-wrapper {
            display: flex;
            align-items: center;    /* Vertical centering of the .text-content block */
            justify-content: center; /* Horizontal centering of the .text-content block */
            /* Padding will be set dynamically by JS in adjustTextElementWrapperSize */
        }

        /* Content inside the wrapper - where opacity is applied */
        /* This class will now ONLY be applied to the actual content: img, audio, or text div */
        .element-content {
            display: block; /* Ensures proper sizing for images and text divs */
            object-fit: contain; /* For images, maintains aspect ratio within bounds */
            width: 100%; /* Make content take full width of wrapper for images/videos */
            height: 100%; /* Make content take full height of wrapper for images/videos */
            /* Text content styles will override these for text elements */
        }

        /* New class for the visual audio icon */
        .audio-visual-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            width: 100%;
            pointer-events: none; /* Prevent this div from interfering with drag/select of wrapper */
        }

        .text-content {
            white-space: pre-wrap; /* Preserve whitespace and allow wrapping */
            word-break: break-word; /* Break long words */
            text-align: center; /* Center text horizontally within the block */
            box-sizing: border-box; /* Ensure border and padding are included in element's total width and height */
            line-height: 1; /* IMPORTANT: Minimize intrinsic line height for precise centering */
            padding: 0px; /* Ensure no residual padding that conflicts with wrapper padding */
            
            /* NEW: Make text-content a flex container to center its own content */
            display: flex;
            align-items: center; /* Center text vertically within text-content */
            justify-content: center; /* Center text horizontally within text-content */
        }

        .resize-handle {
            position: absolute;
            width: 10px; /* Smaller squares */
            height: 10px;
            background-color: #8B5CF6; /* Purple color */
            border: 1px solid #ffffff;
            cursor: grab; /* General grab cursor for handles initially */
            z-index: 1000; /* Ensure handles are on top */
        }
        /* Cursors for specific resize handles */
        .resize-handle.top-left { top: -5px; left: -5px; cursor: nwse-resize; }
        .resize-handle.top-right { top: -5px; right: -5px; cursor: nesw-resize; }
        .resize-handle.bottom-left { bottom: -5px; left: -5px; cursor: nesw-resize; }
        .resize-handle.bottom-right { bottom: -5px; right: -5px; cursor: nwse-resize; }

        .rotation-handle {
            position: absolute;
            top: -25px; /* Position above the element */
            left: 50%;
            transform: translateX(-50%); /* Center horizontally */
            width: 20px;
            height: 20px;
            background-color: #8B5CF6; /* Purple color */
            border-radius: 50%; /* Circular shape */
            border: 1px solid #ffffff;
            cursor: grab;
            z-index: 1000;
            display: none; /* Hidden by default */
        }

        /* Custom scrollbar for sidebar */
        .sidebar-scroll {
            overflow-y: auto;
            -ms-overflow-style: none; /* IE and Edge */
            scrollbar-width: none; /* Firefox */
        }
        .sidebar-scroll::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        /* Tab styling */
        .tab-button {
            padding: 0.35rem 1rem;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            font-weight: 600;
            color: #A0AEC0; /* gray-400 */
            transition: all 0.2s ease-in-out;
            padding-left: 1rem;
            padding-right: 1rem;
        }
        .tab-button.active {
            border-bottom-color: transparent;
            background-color: #4A5568; /* gray-700 background */
            color: #FFFFFF;
        }
        .tab-content {
            display: none;
            padding-top: 0.5rem;
        }
        .tab-content.active {
            display: block;
        }
        .layer-item {
            display: flex;
            align-items: center;
            padding: 0.5rem 0.75rem;
            background-color: #2D3748; /* gray-800 */
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            color: #E2E8F0; /* gray-200 */
        }
        .layer-item:hover {
            background-color: #4A5568; /* gray-700 */
        }
        .layer-item.selected {
            background-color: #8B5CF6; /* purple-500 */
            color: #FFFFFF;
        }
        /* Style for active bold/italic buttons */
        button.active-style {
            background-color: #8B5CF6; /* purple-500 */
            border: 1px solid #7C3AED; /* purple-600 */
        }

        .reset-button {
            background: none;
            border: none;
            cursor: pointer;
            color: #A0AEC0; /* gray-400 */
            padding: 0.25rem;
            line-height: 1; /* Adjust to better align icon */
        }
        .reset-button:hover {
            color: #E2E8F0; /* gray-200 */
        }

        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-color: transparent;
            border: none;
            cursor: pointer;
            width: 100%;
            height: 2.5rem;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch {
            border: none;
        }
        input[type="color"]::-moz-color-remap-panel {
            border: none;
        }
        input[type="color"]::-moz-color-swatch {
        }

        /* Custom styles for file input to hide default text */
        .custom-file-input {
            position: relative;
            overflow: hidden;
            display: inline-block;
            cursor: pointer;
        }

        .custom-file-input input[type="file"] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }

        /* Responsive layout for mobile */
        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }
            aside {
                width: 100%;
                height: auto;
                max-height: 50vh;
            }
            main {
                flex-grow: 1;
                width: 100%;
                margin: 0.5rem;
            }
        }

        /* Styles for range input (sliders) */
        input[type="range"].w-full {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
            width: 100%;
            height: 8px;
        }

        /* Track styles for Webkit (Chrome, Safari, Edge) */
        input[type="range"].w-full::-webkit-slider-runnable-track {
            background: #4A5568; /* gray-700 for the track */
            border-radius: 4px;
            height: 4px;
        }

        /* Thumb styles for Webkit - General, will be overridden by #zoomRange if more specific */
        input[type="range"].w-full::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            background-color: #8B5CF6; /* Beautiful purple */
            border: 1px solid #FFFFFF;
            border-radius: 50%;
            height: 16px;
            width: 16px;
            margin-top: -6px;
        }

        /* Track styles for Firefox */
        input[type="range"].w-full::-moz-range-track {
            background: #4A5568; /* gray-700 for the track */
            border-radius: 4px;
            height: 4px;
        }

        /* Thumb styles for Firefox - General, will be overridden by #zoomRange if more specific */
        input[type="range"].w-full::-moz-range-thumb {
            background-color: #8B5CF6; /* Beautiful purple */
            border: 1px solid #FFFFFF;
            border-radius: 50%;
            height: 16px;
            width: 16px;
        }

        /* Main canvas container now acts as a flex container for its children */
        main#editorCanvas {
            position: relative; /* Keep relative for absolute children positioning */
            flex-grow: 1; /* Allow it to take available space */
            display: flex; /* Use flexbox to arrange innerCanvas and new sidebar */
            align-items: center; /* Vertically center children within editorCanvas */
            justify-content: center; /* Horizontally center the mainCanvasWrapper */
            margin: 1rem; /* Adjust margin as needed */
            overflow: hidden; /* Hide anything that goes outside innerCanvas */
        }

        /* New wrapper for both canvases */
        #mainCanvasWrapper {
            display: flex; /* Arrange inner canvases side by side */
            position: relative; /* For absolutely positioned elements */
            width: 1496px; /* 200px (leftSidebar) + 16px (margin) + 1280px (innerCanvas) */
            height: 720px; /* Same height as innerCanvas */
            transform-origin: center center; /* Scale from the center of the combined wrapper */
            flex-shrink: 0; /* Prevent it from shrinking */
        }

        /* New green sidebar to the left */
        #leftSidebar {
            width: 200px; /* Much narrower than innerCanvas */
            height: 720px; /* Same height as innerCanvas */
            background-color: rgba(16, 185, 129, 0.5); /* Green color (emerald-500 equivalent) with transparency */
            border: 2px dashed #4ade80; /* Lighter green dashed border */
            margin-right: 1rem; /* Space between the two canvases */
            flex-shrink: 0; /* Prevent it from shrinking */
        }

        /* Inner canvas with fixed dimensions for consistent output */
        #innerCanvas {
            width: 1280px; /* Fixed width for consistent output */
            height: 720px; /* Fixed height for consistent output (16:9 aspect ratio) */
            background-color: #22323e; /* Darker green background */
            border: 2px dashed white; /* Border directly on the canvas */
            flex-shrink: 0; /* Prevent it from shrinking smaller than its size */
        }


        /* Style for the drag and drop area */
        #dropArea {
            border: 2px dashed #4A5568; /* Dark gray dashed border */
            background-color: #2D3748; /* Darker gray background */
            text-align: center;
            padding: 1rem;
            margin-top: 1rem;
            color: #A0AEC0; /* Light gray text */
            font-size: 0.875rem; /* text-sm */
            border-radius: 0.5rem; /* rounded-lg */
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
        }

        #dropArea.highlight {
            background-color: #4A5568; /* Highlight background on dragover */
            border-color: #8B5CF6; /* Purple border on highlight */
        }

        /* Specific styles for the new zoom slider thumb */
        #newZoomRange::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            background-color: #8B5CF6; /* Purple for zoom thumb */
            border: 1px solid #FFFFFF;
            border-radius: 50%;
            height: 16px;
            width: 16px;
            margin-top: -5px; /* Adjusted to -5px */
        }

        #newZoomRange::-moz-range-thumb {
            background-color: #8B5CF6; /* Purple for zoom thumb */
            border: 1px solid #FFFFFF;
            border-radius: 50%;
            height: 16px;
            width: 16px;
            margin-top: -5px; /* Adjusted to -5px */
        }
        /* Styling for the loading spinner */
        #loadingSpinner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 1.5rem 2rem;
            border-radius: 0.75rem;
            z-index: 1000;
            display: flex; /* Always use flex for alignment */
            align-items: center;
            gap: 1rem;
            font-size: 1.125rem;
            font-weight: 600;
        }
        #loadingSpinner.hidden {
            display: none; /* Override flex when hidden */
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #8B5CF6; /* Purple */
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* WebSocket status indicator */
        #wsStatus {
            font-size: 0.75rem; /* text-xs */
            font-weight: 500;
            margin-top: 0.5rem;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            text-align: center;
        }
        #wsStatus.connected {
            background-color: #10B981; /* emerald-500 */
            color: #064E40; /* emerald-900 */
        }
        #wsStatus.disconnected {
            background-color: #EF4444; /* red-500 */
            color: #7F1D1D; /* red-900 */
        }
        #wsStatus.connecting {
            background-color: #FBBF24; /* amber-400 */
            color: #78350F; /* amber-900 */
        }

    </style>
</head>
<body class="h-screen flex text-gray-800">
    <!-- Loading Spinner -->
    <div id="loadingSpinner" class="hidden"> <!-- Hidden by default, only shown if needed for initial loading -->
        <div class="spinner"></div>
        Cargando elementos...
    </div>

    <aside class="w-80 bg-gray-900 shadow-lg flex flex-col sidebar-scroll text-gray-200 md:w-80 pt-4 z-20"> <!-- Added z-20 to ensure sidebar is on top -->
        <div class="border-b pb-2 border-gray-700 px-4">
            <label for="imageUpload" class="block text-sm font-medium text-gray-300 mb-2 text-center">Subir Imagen/GIF/MP3</label>
            <div class="custom-file-input w-full bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2 px-4 cursor-pointer transition-colors duration-200 text-center">
                <span id="selectFileButtonText">Seleccionar archivo</span>
                <input type="file" id="imageUpload" accept="image/*, .gif, audio/mpeg" class="block w-full text-sm text-gray-400">
            </div>
            <span id="fileCountDisplay" class="block text-xs text-gray-400 mt-2 text-center">0/50</span> <!-- Changed file limit here -->

            <!-- New Drag and Drop Area -->
            <div id="dropArea">Arrastra y suelta archivos aquí</div>

            <!-- WebSocket Status Indicator -->
            <div id="wsStatus" class="disconnected">Desconectado</div>
        </div>

        <div class="flex border-b border-gray-700">
            <button class="tab-button active flex-1 text-center" data-tab="properties">Ajustes</button> <!-- Changed "Propiedades" to "Ajustes" -->
            <button class="tab-button flex-1 text-center" data-tab="text">Texto</button>
            <button class="tab-button flex-1 text-center" data-tab="audio">Audio</button> <!-- NEW Audio Tab -->
            <button class="tab-button flex-1 text-center" data-tab="layers">Capas</button>
        </div>

        <div id="tab-content-properties" class="tab-content active flex-grow px-4">
            <h2 class="text-lg font-semibold mb-4 text-purple-400">Controles de Elemento</h2>

            <div class="mb-4">
                <label for="opacityRange" class="block text-sm font-medium text-gray-300 mb-2">Opacidad</label>
                <div class="flex items-center space-x-2">
                    <input type="range" id="opacityRange" min="0" max="1" step="0.01" value="1" disabled class="w-full h-2 bg-gray-700 appearance-none cursor-pointer range-shadow">
                    <span id="opacityValue" class="text-xs text-gray-400 w-10 text-right">100%</span>
                    <button id="resetOpacityBtn" class="reset-button" title="Reiniciar Opacidad" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-4 h-4">
                            <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
                        </svg>
                    </button>
                </div>
            </div>

            <div class="mb-6">
                <label for="rotationRange" class="block text-sm font-medium text-gray-300 mb-2">Rotación</label>
                <div class="flex items-center space-x-2">
                    <input type="range" id="rotationRange" min="0" max="360" step="1" value="0" disabled class="w-full h-2 bg-gray-700 appearance-none cursor-pointer range-shadow">
                    <span id="rotationValue" class="text-xs text-gray-400 w-10 text-right">0°</span>
                    <button id="resetRotationBtn" class="reset-button" title="Reiniciar Rotación" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-4 h-4">
                            <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
                        </svg>
                    </button>
                </div>
            </div>

            <button id="duplicateElementBtn" disabled class="w-full bg-purple-700 hover:bg-purple-800 text-white font-bold py-2 px-4 shadow-md transition-all duration-200 mb-3 disabled:opacity-50 disabled:cursor-not-allowed">
                Duplicar elemento
            </button>
            <button id="bringToFrontBtn" disabled class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 shadow-md transition-all duration-200 mb-3 disabled:opacity-50 disabled:cursor-not-allowed">
                Traer al frente
            </button>
            <button id="deleteElementBtn" disabled class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 shadow-md transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed mb-4">
                Eliminar elemento
            </button>
        </div>

        <div id="tab-content-text" class="tab-content flex-grow px-4">
            <label for="textInput" class="block text-sm font-medium text-gray-300 mb-2">Contenido del Texto</label>
            <textarea id="textInput" class="w-full p-2 border border-gray-600 bg-gray-700 text-gray-100 focus:outline-none focus:ring-purple-400" rows="3" placeholder="Escribe aquí el texto"></textarea>
            <button id="addTextBtn" class="w-full bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 shadow-md transition-all duration-200 mb-4">
                Añadir Texto al Lienzo
            </button>

            <h3 class="text-md font-semibold mb-2 text-purple-400 mt-6">Ajustes de Estilo de Texto</h3>

            <div class="flex space-x-2 mb-4">
                <button id="boldTextBtn" class="flex-1 bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 shadow-md transition-all duration-200">
                    Negrita
                </button>
                <button id="italicTextBtn" class="flex-1 bg-gray-700 hover:bg-gray-600 text-white italic py-2 px-4 shadow-md transition-all duration-200">
                    Cursiva
                </button>
            </div>

            <div class="mb-4">
                <label for="fontSizeRange" class="block text-sm font-medium text-gray-300 mb-2">Tamaño del Texto</label>
                <div class="flex items-center space-x-2">
                    <input type="range" id="fontSizeRange" min="10" max="100" step="1" value="24" class="w-full h-2 bg-gray-700 appearance-none cursor-pointer range-shadow">
                    <span id="fontSizeValue" class="text-xs text-gray-400 w-10 text-right">24px</span>
                </div>
            </div>

            <div class="mb-4">
                <label for="textColor" class="block text-sm font-medium text-gray-300 mb-2">Color del Texto</label>
                <input type="color" id="textColor" value="#FFFFFF" class="w-full h-8 border border-gray-600 bg-gray-700 p-1 cursor-pointer">
            </div>

            <div class="mb-4">
                <div class="flex items-center justify-between space-x-2">
                    <label for="toggleTextBg" class="text-sm font-medium text-gray-300 cursor-pointer">Fondo del Texto</label>
                    <div class="flex items-center space-x-2">
                        <input type="checkbox" id="toggleTextBg" class="h-4 w-4 text-purple-600 bg-gray-700 border-gray-600 focus:ring-purple-500">
                        <label for="toggleTextBg" class="text-sm font-medium text-gray-300 cursor-pointer">Activar</label>
                    </div>
                </div>
                <!-- Nested div for indentation -->
                <div class="pl-4 border-l border-gray-700 mt-2">
                    <label id="textBgColorLabel" for="textBgColor" class="block text-sm font-medium text-gray-400 mb-2 mt-2 disabled:text-gray-600">Color de Fondo del Texto</label>
                    <input type="color" id="textBgColor" value="#000000" class="w-full h-8 border border-gray-600 bg-gray-700 p-1 cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed disabled:bg-gray-800">
                </div>
            </div>

            <div class="mb-4">
                <div class="flex items-center justify-between space-x-2">
                    <label for="toggleTextOutline" class="text-sm font-medium text-gray-300 cursor-pointer">Contorno del Texto</label>
                    <div class="flex items-center space-x-2">
                        <input type="checkbox" id="toggleTextOutline" class="h-4 w-4 text-purple-600 bg-gray-700 border-gray-600 focus:ring-purple-500">
                        <label for="toggleTextOutline" class="text-sm font-medium text-gray-300 cursor-pointer">Activar</label>
                    </div>
                </div>
                <!-- Nested div for indentation -->
                <div class="pl-4 border-l border-gray-700 mt-2">
                    <label id="textOutlineColorLabel" for="textOutlineColor" class="block text-sm font-medium text-gray-400 mb-2 mt-2 disabled:text-gray-600">Color del Contorno</label>
                    <input type="color" id="textOutlineColor" value="#000000" class="w-full h-8 border border-gray-600 bg-gray-700 p-1 cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed disabled:bg-gray-800">

                    <label id="outlineThicknessLabel" for="outlineThicknessRange" class="block text-sm font-medium text-gray-400 mb-2 mt-4 disabled:text-gray-600">Grosor del Contorno</label>
                    <div class="flex items-center space-x-2">
                        <input type="range" id="outlineThicknessRange" min="0" max="5" step="0.1" value="0" disabled class="w-full h-2 bg-gray-700 appearance-none cursor-pointer range-shadow">
                        <span id="outlineThicknessValue" class="text-xs text-gray-400 w-10 text-right">0px</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- NEW Audio Controls Tab -->
        <div id="tab-content-audio" class="tab-content flex-grow px-4">
            <h2 class="text-lg font-semibold mb-4 text-purple-400">Controles de Audio</h2>

            <div class="flex items-center justify-center space-x-4 mb-4">
                <button id="playPauseBtn" disabled class="bg-purple-600 hover:bg-purple-700 text-white font-bold p-3 rounded-full shadow-md transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                    <svg id="playIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6">
                        <path fill-rule="evenodd" d="M4.5 5.653c0-1.426 1.529-2.38 2.872-1.667l11.553 6.917c1.164.696 1.164 2.67 0 3.366l-11.553 6.917C6.029 21.38 4.5 20.426 4.5 19.0V5.653Z" clip-rule="evenodd" />
                    </svg>
                    <svg id="pauseIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6 hidden">
                        <path fill-rule="evenodd" d="M6.75 5.25a.75.75 0 0 1 .75-.75H9a.75.75 0 0 1 .75.75v13.5a.75.75 0 0 1-.75.75H7.5a.75.75 0 0 1-.75-.75V5.25ZM14.25 5.25a.75.75 0 0 1 .75-.75h1.5a.75.75 0 0 1 .75.75v13.5a.75.75 0 0 1-.75.75h-1.5a.75.75 0 0 1-.75-.75V5.25Z" clip-rule="evenodd" />
                    </svg>
                </button>
            </div>

            <div class="mb-4">
                <label for="volumeRange" class="block text-sm font-medium text-gray-300 mb-2">Volumen</label>
                <div class="flex items-center space-x-2">
                    <input type="range" id="volumeRange" min="0" max="1" step="0.01" value="0.5" disabled class="w-full h-2 bg-gray-700 appearance-none cursor-pointer range-shadow">
                    <span id="volumeValue" class="text-xs text-gray-400 w-10 text-right">50%</span>
                </div>
            </div>

            <div class="mb-4">
                <label for="timelineRange" class="block text-sm font-medium text-gray-300 mb-2">Línea de tiempo</label>
                <div class="flex items-center space-x-2">
                    <input type="range" id="timelineRange" min="0" max="100" step="0.1" value="0" disabled class="w-full h-2 bg-gray-700 appearance-none cursor-pointer range-shadow">
                    <span id="currentTimeDisplay" class="text-xs text-gray-400 w-16 text-right">0:00 / 0:00</span>
                </div>
            </div>
            
            <!-- NEW Global Mute/Unmute Button -->
            <div class="mb-4 pt-4 border-t border-gray-700 text-center">
                <button id="muteToggleBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-200">
                    <div class="flex items-center justify-center space-x-2">
                        <!-- Volume On Icon (initially hidden) -->
                        <svg id="volumeOnIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5 hidden">
                            <path d="M13.5 4.062c0-1.096.712-2.036 1.748-2.562s2.308-.256 3.056.635A6.495 6.495 0 0 1 22.5 8.25c0 1.542-.516 3.06-1.551 4.316l-5.753 5.754a2.25 2.25 0 0 1-3.182-3.182l.398-.398A5.25 5.25 0 0 0 18 8.25c0-1.12.373-2.143 1-2.982V9.75a.75.75 0 0 0 1.5 0V6a.75.75 0 0 0-.75-.75h-3.75a.75.75 0 0 0 0 1.5h.94l-2.47 2.47a.75.75 0 0 0 1.06 1.06L15.75 7.5c1.474.45 2.763 1.157 3.75 2.083v-3.11c-.443.084-.891.137-1.35.137-2.325 0-4.515-1.01-5.918-2.772Z" />
                            <path fill-rule="evenodd" d="M9.75 2.25A.75.75 0 0 0 9 3v.75H4.875a.75.75 0 0 0-.75.75v3.375c0 .621.504 1.125 1.125 1.125H9.75v1.5H5.625c-.621 0-1.125.504-1.125 1.125V16.5c0 .621.504 1.125 1.125 1.125H9.75v.75a.75.75 0 0 0 1.5 0v-.75h1.875a.75.75 0 0 0 .75-.75v-3.375a.75.75 0 0 0-1.125-.621l-5.625 3.375c-.621.373-1.393-.153-1.393-.879V7.125c0-.726.772-1.252 1.393-.879l5.625 3.375a.75.75 0 0 0 1.125-.621V3a.75.75 0 0 0-.75-.75H9.75Z" clip-rule="evenodd" />
                        </svg>
                        <!-- Volume Off Icon (initially visible, as muted by default) -->
                        <svg id="volumeOffIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5">
                            <path fill-rule="evenodd" d="M7.708 2.222c-.49-.785-.304-1.786.411-2.328A.75.75 0 0 1 8.25 0h7.5a.75.75 0 0 1 .59.294c.715.542.901 1.543.41 2.328A10.05 10.05 0 0 0 12 2.25a10.05 10.05 0 0 0-4.292-.028ZM12 4.5c-1.581 0-3.107.039-4.59.112C6.798 5.732 6 6.643 6 7.75V15.75c0 1.107.798 2.018 1.41 2.138 1.483.073 3.01.112 4.59.112s3.107-.039 4.59-.112c.612-.12 1.41-.013 1.41-1.125V7.75c0-1.107-.798-2.018-1.41-2.138A10.05 10.05 0 0 0 12 4.5Z" clip-rule="evenodd" />
                            <path d="M15 8.25a.75.75 0 0 0-.75.75v4.5c0 .414.336.75.75.75h.75a.75.75 0 0 0 .75-.75V9a.75.75 0 0 0-.75-.75h-.75Zm-3 0a.75.75 0 0 0-.75.75v4.5c0 .414.336.75.75.75h.75a.75.75 0 0 0 .75-.75V9a.75.75 0 0 0-.75-.75h-.75Zm-3 0a.75.75 0 0 0-.75.75v4.5c0 .414.336.75.75.75h.75a.75.75 0 0 0 .75-.75V9a.75.75 0 0 0-.75-.75h-.75Z" />
                        </svg>
                        <span id="muteButtonText">Silenciar página</span>
                    </div>
                </button>
            </div>

        </div>
        <!-- END NEW Audio Controls Tab -->

        <div id="tab-content-layers" class="tab-content flex-grow px-4">
            <h2 class="text-lg font-semibold mb-4 text-purple-400">Capas de Elementos</h2>
            
            <div id="layersList" class="space-y-2">
                <p class="text-gray-400 text-sm">No hay elementos en la página.</p>
            </div>
        </div>

    </aside>

    <main id="editorCanvas" class="relative m-4 shadow-inner">
        <!-- Main wrapper for both canvases and all elements -->
        <div id="mainCanvasWrapper">
            <!-- Nuevo Rectángulo Verde -->
            <div id="leftSidebar"></div>
            <!-- Inner canvas will hold all elements for consistent positioning -->
            <div id="innerCanvas">
                <!-- Elements will be appended directly to mainCanvasWrapper now -->
            </div>
        </div>
    </main>

    <!-- Re-created Zoom Controls -->
    <div class="absolute bottom-4 right-4 bg-gray-800 p-2 rounded-lg shadow-xl z-50 flex items-center space-x-2 zoom-controls">
        <label for="newZoomRange" class="text-sm font-medium text-gray-300">Zoom</label>
        <input type="range" id="newZoomRange" min="0.25" max="2.0" step="0.05" value="1.0" class="w-24 h-2 bg-gray-700 appearance-none cursor-pointer">
        <span id="zoomValue" class="text-xs text-gray-400">100%</span>
    </div>

    <script>
        // editorCanvas is the outermost container responsible for centering
        const editorCanvas = document.getElementById('editorCanvas'); 
        // mainCanvasWrapper is the new parent that holds both sidebars and all elements
        const mainCanvasWrapper = document.getElementById('mainCanvasWrapper');
        // leftSidebar is the green canvas on the left
        const leftSidebar = document.getElementById('leftSidebar');
        // innerCanvas is the main blue canvas
        const innerCanvas = document.getElementById('innerCanvas');


        const sidebar = document.querySelector('aside');
        const imageUpload = document.getElementById('imageUpload');
        const addTextBtn = document.getElementById('addTextBtn');
        const textInput = document.getElementById('textInput');
        const opacityRange = document.getElementById('opacityRange');
        const opacityValue = document.getElementById('opacityValue');
        const rotationRange = document.getElementById('rotationRange');
        const rotationValue = document.getElementById('rotationValue');
        const duplicateElementBtn = document.getElementById('duplicateElementBtn');
        const deleteElementBtn = document.getElementById('deleteElementBtn');
        const layersList = document.getElementById('layersList');
        const bringToFrontBtn = document.getElementById('bringToFrontBtn');

        // Text styling controls
        const textColorInput = document.getElementById('textColor');
        const textBgColorInput = document.getElementById('textBgColor');
        const boldTextBtn = document.getElementById('boldTextBtn');
        const italicTextBtn = document.getElementById('italicTextBtn');
        const toggleTextBg = document.getElementById('toggleTextBg');

        // New Outline controls
        const toggleTextOutline = document.getElementById('toggleTextOutline');
        const textOutlineColorInput = document.getElementById('textOutlineColor');
        const outlineThicknessRange = document.getElementById('outlineThicknessRange');
        const outlineThicknessValue = document.getElementById('outlineThicknessValue');

        // New Font Size controls
        const fontSizeRange = document.getElementById('fontSizeRange');
        const fontSizeValue = document.getElementById('fontSizeValue');

        // Reset buttons
        const resetOpacityBtn = document.getElementById('resetOpacityBtn');
        const resetRotationBtn = document.getElementById('resetRotationBtn');

        // NEW Audio controls references
        const audioControlsSection = document.getElementById('tab-content-audio');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const playIcon = document.getElementById('playIcon');
        const pauseIcon = document.getElementById('pauseIcon');
        const volumeRange = document.getElementById('volumeRange');
        const volumeValueDisplay = document.getElementById('volumeValue');
        const timelineRange = document.getElementById('timelineRange');
        const currentTimeDisplay = document.getElementById('currentTimeDisplay');

        // NEW Global Mute/Unmute button references
        const muteToggleBtn = document.getElementById('muteToggleBtn');
        const volumeOnIcon = document.getElementById('volumeOnIcon');
        const volumeOffIcon = document.getElementById('volumeOffIcon');
        const muteButtonText = document.getElementById('muteButtonText');


        // File upload limit
        const fileLimit = 50; // Changed file limit from 500 to 50
        const fileCountDisplay = document.getElementById('fileCountDisplay');
        const selectFileButtonText = document.getElementById('selectFileButtonText');

        // New references for labels to change their color
        const textBgColorLabel = document.getElementById('textBgColorLabel');
        const textOutlineColorLabel = document.getElementById('textOutlineColorLabel');
        const outlineThicknessLabel = document.getElementById('outlineThicknessLabel');

        // Zoom controls (Updated ID)
        const zoomRange = document.getElementById('newZoomRange'); // Changed ID to newZoomRange
        const zoomValue = document.getElementById('zoomValue');

        // Drag and drop area
        const dropArea = document.getElementById('dropArea');

        // Loading Spinner
        const loadingSpinner = document.getElementById('loadingSpinner');

        // WebSocket status element
        const wsStatusElement = document.getElementById('wsStatus');

        let selectedElementWrapper = null;
        let isDragging = false;
        let isResizing = false;
        let isRotating = false;
        let activeHandle = '';
        let initialMouseX, initialMouseY; // Mouse/touch position in unscaled canvas coordinates
        let initialLeft, initialTop, initialWidth, initialHeight; // Element properties in unscaled canvas coordinates
        let initialRotationAngle = 0; // Viewport angle for rotation
        let initialElementRotation = 0; // Element's current rotation angle

        let currentZoom = 1.0; // Initial zoom level
        let isMutedGlobally = true; // Default to muted

        const allElements = new Map();

        // --- WebSocket Setup ---
        // Cambia esta URL si tu servidor WebSocket no se ejecuta en localhost:8080
        const WS_URL = 'ws://localhost:8080';
        let ws;
        let reconnectInterval;
        let pendingUpdateAnimationFrame = null; // Variable para controlar el requestAnimationFrame para updates

        function connectWebSocket() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                console.log('WebSocket ya conectado.');
                return;
            }
            updateWsStatus('connecting');
            ws = new WebSocket(WS_URL);

            ws.onopen = () => {
                console.log('Conectado al servidor WebSocket');
                updateWsStatus('connected');
                // Cuando se conecta, el servidor enviará el estado inicial.
                // localStorage se usará como un caché, pero la fuente de verdad es el servidor.
                if (reconnectInterval) {
                    clearInterval(reconnectInterval);
                    reconnectInterval = null;
                }
            };

            ws.onmessage = (event) => {
                const message = JSON.parse(event.data);
                // console.log('Mensaje recibido del servidor:', message);

                if (message.type === 'initialState') {
                    // Recibir el estado inicial del servidor
                    // Esto reemplaza completamente el estado local
                    allElements.clear(); // Limpia los elementos existentes
                    mainCanvasWrapper.querySelectorAll('.element-wrapper').forEach(el => el.remove()); // Elimina todos los elementos del DOM

                    message.elements.forEach(data => {
                        createElementFromData(data); // Recrea los elementos del estado del servidor
                    });
                    updateLayersList();
                    updateFileCountDisplay();
                    deselectAllElements(); // Asegura que los controles estén en el estado correcto
                } else if (message.type === 'elementAdd') {
                    createElementFromData(message.element);
                    updateLayersList();
                    updateFileCountDisplay();
                } else if (message.type === 'elementUpdate') {
                    // **MODIFICACIÓN AQUÍ**: Siempre actualiza el elemento desde los datos del mensaje.
                    // La lógica de "no actualizar si está seleccionado localmente" se ha eliminado.
                    updateElementFromData(message.element);
                    updateLayersList();
                } else if (message.type === 'elementDelete') {
                    deleteElementFromData(message.elementId);
                    updateLayersList();
                    updateFileCountDisplay();
                } else if (message.type === 'reorderLayers') {
                    // El servidor ha dictado un nuevo orden de z-index
                    message.elements.forEach(elementData => {
                        const elementWrapper = allElements.get(elementData.id);
                        if (elementWrapper) {
                            elementWrapper.style.zIndex = elementData.zIndex;
                        }
                    });
                    updateLayersList(); // Re-renderiza la lista de capas para reflejar el nuevo orden
                } else if (message.type === 'ping') {
                    // Opcional: El cliente puede responder con un 'pong' si el servidor lo requiere
                    // ws.send(JSON.stringify({ type: 'pong' }));
                }
            };

            ws.onclose = () => {
                console.log('Desconectado del servidor WebSocket. Intentando reconectar...');
                updateWsStatus('disconnected');
                if (!reconnectInterval) {
                    reconnectInterval = setInterval(connectWebSocket, 5000); // Intenta reconectar cada 5 segundos
                }
            };

            ws.onerror = (err) => {
                console.error('Error de WebSocket:', err);
                ws.close(); // Intenta cerrar la conexión para activar onclose y reconectar
            };
        }

        // Función para enviar mensajes al servidor WebSocket
        function sendWebSocketMessage(type, data) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type, ...data }));
            } else {
                console.warn('WebSocket no conectado, no se pudo enviar el mensaje:', type, data);
            }
        }

        // Función para actualizar el estado de conexión de WebSocket en la UI
        function updateWsStatus(status) {
            wsStatusElement.classList.remove('connected', 'disconnected', 'connecting');
            if (status === 'connected') {
                wsStatusElement.classList.add('connected');
                wsStatusElement.textContent = 'Conectado';
            } else if (status === 'disconnected') {
                wsStatusElement.classList.add('disconnected');
                wsStatusElement.textContent = 'Desconectado';
            } else if (status === 'connecting') {
                wsStatusElement.classList.add('connecting');
                wsStatusElement.textContent = 'Conectando...';
            }
        }

        // --- Fin Configuración WebSocket ---

        // --- Utility Functions ---
        function generateUniqueId() {
            // Se usa Date.now() y Math.random() para asegurar alta probabilidad de unicidad
            // en un entorno distribuido, aunque la unicidad absoluta debería ser manejada por el servidor
            // si hubiera una base de datos persistente. Para este caso de WebSockets, es suficiente.
            return 'element-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        }

        // Function to get the next highest z-index across ALL elements on mainCanvasWrapper
        function getNextHighestZIndex() {
            let maxZ = 0;
            // Iterate over all actual element wrappers on the mainCanvasWrapper
            mainCanvasWrapper.querySelectorAll('.element-wrapper').forEach(elementWrapper => {
                const currentZ = parseInt(elementWrapper.style.zIndex || 0);
                if (currentZ > maxZ) {
                    maxZ = currentZ;
                }
            });
            return maxZ + 1;
        }

        // Function to apply zoom to the main canvas wrapper
        function applyZoom() {
            mainCanvasWrapper.style.transform = `scale(${currentZoom})`;
            mainCanvasWrapper.style.transformOrigin = 'center center'; // Scale from the center of the combined wrapper
            zoomValue.textContent = `${Math.round(currentZoom * 100)}%`;
        }

        /**
         * Formats time in seconds to mm:ss string.
         * @param {number} seconds - The time in seconds.
         * @returns {string} Formatted time string (mm:ss).
         */
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}`;
        }

        /**
         * Generates the CSS text-shadow property for a text outline effect.
         * @param {number} thickness - The thickness of the outline in pixels.
         * @param {string} color - The color of the outline (e.g., '#000000', 'rgb(0,0,0)').
         * @returns {string} The CSS text-shadow value or 'none' if thickness is 0.
         */
        function generateTextShadowForOutline(thickness, color) {
            if (parseFloat(thickness) === 0) return 'none';
            const t = parseFloat(thickness);
            let shadow = [];
            // Generate shadows around the text for a better outline effect
            // We use 8 directions for a robust outline
            shadow.push(`${-t}px ${-t}px 0 ${color}`); // Top-left
            shadow.push(`${0}px ${-t}px 0 ${color}`);  // Top
            shadow.push(`${t}px ${-t}px 0 ${color}`);  // Top-right
            shadow.push(`${-t}px ${0}px 0 ${color}`);  // Left
            shadow.push(`${t}px ${0}px 0 ${color}`);   // Right
            shadow.push(`${-t}px ${t}px 0 ${color}`);  // Bottom-left
            shadow.push(`${0}px ${t}px 0 ${color}`);   // Bottom
            shadow.push(`${t}px ${t}px 0 ${color}`);   // Bottom-right

            return shadow.join(', ');
        }

        /**
         * Adjusts the width and height of a text element's wrapper to fit its content, including padding and centering.
         * @param {HTMLElement} elementWrapper - The .element-wrapper div containing the text.
         */
        function adjustTextElementWrapperSize(elementWrapper) {
            const textElement = elementWrapper.querySelector('.element-content');
            if (!textElement) return;

            // Store current computed styles for textElement that might affect its size
            const computedStyle = window.getComputedStyle(textElement);
            
            // Create a temporary, invisible element to measure the text's intrinsic size accurately
            const tempDiv = document.createElement('div');
            tempDiv.style.position = 'absolute';
            tempDiv.style.visibility = 'hidden';
            tempDiv.style.left = '-9999px'; // Move off-screen
            tempDiv.style.top = '-9999px';
            tempDiv.style.height = 'auto'; // Allow height to be natural
            tempDiv.style.width = 'auto';  // Allow width to be natural
            tempDiv.style.whiteSpace = 'pre-wrap'; // Matches text-content
            tempDiv.style.wordBreak = 'break-word'; // Corrected: Use camelCase for JS style property
            tempDiv.style.boxSizing = 'border-box'; // Matches text-content
            tempDiv.style.lineHeight = '1'; // IMPORTANT: Minimize intrinsic line height for precise centering
            tempDiv.style.textAlign = 'center'; // Copy text alignment

            // NEW: Add flex properties to tempDiv for accurate measurement
            tempDiv.style.display = 'flex';
            tempDiv.style.alignItems = 'center';
            tempDiv.style.justifyContent = 'center';

            // Copy all relevant computed styles from the actual text element
            tempDiv.style.fontSize = computedStyle.fontSize;
            tempDiv.style.fontWeight = computedStyle.fontWeight;
            tempDiv.style.fontStyle = computedStyle.fontStyle;
            tempDiv.style.fontFamily = computedStyle.fontFamily;
            tempDiv.style.color = computedStyle.color; // Crucial for text-stroke fill color
            tempDiv.style.backgroundColor = computedStyle.backgroundColor; // For background color
            
            // Copy outline styles if active
            // Retrieve outline properties directly from the element if they exist
            const outlineThickness = parseFloat(textElement.style.webkitTextStrokeWidth) || 0;
            const outlineColor = textElement.style.webkitTextStrokeColor || '#000000';

            if (outlineThickness > 0) {
                tempDiv.style.webkitTextStrokeWidth = `${outlineThickness}px`;
                tempDiv.style.webkitTextStrokeColor = outlineColor;
                tempDiv.style.textShadow = generateTextShadowForOutline(outlineThickness, outlineColor);
            } else {
                tempDiv.style.webkitTextStrokeWidth = '0';
                tempDiv.style.webkitTextStrokeColor = 'transparent';
                tempDiv.style.textShadow = 'none';
            }
            
            tempDiv.textContent = textElement.textContent;

            document.body.appendChild(tempDiv);

            const rawTextRect = tempDiv.getBoundingClientRect();
            const rawContentWidth = rawTextRect.width;
            const rawContentHeight = rawTextRect.height;

            document.body.removeChild(tempDiv);

            // Increased horizontal padding for text background - Adjusted to 25px
            const wrapperPaddingHorizontal = 25; 
            const wrapperPaddingVertical = 10;

            elementWrapper.style.width = `${rawContentWidth + (wrapperPaddingHorizontal * 2)}px`;
            elementWrapper.style.height = `${rawContentHeight + (wrapperPaddingVertical * 2)}px`;

            elementWrapper.style.padding = `${wrapperPaddingVertical}px ${wrapperPaddingHorizontal}px`;
            
            // Ensure the text-content element itself doesn't have internal padding,
            // as padding is now handled by the wrapper.
            textElement.style.padding = '0px';

            // IMPORTANT: Removed the JS setting of display as it's now handled by CSS.
            // textElement.style.display = 'inline-block'; 
        }

        /**
         * Saves the current state of all elements to localStorage.
         * Now also sends updates to the WebSocket server.
         */
        function saveElementsState() {
            const elementsData = [];
            allElements.forEach(elementWrapper => {
                // Now query specific tags for content elements to avoid selecting the audio icon div
                const contentElement = elementWrapper.querySelector('img.element-content, audio.element-content, div.text-content.element-content');
                
                // If an element is still being dragged/resized and hasn't settled, it might not have an element-content
                // Or if it's an audio wrapper, and the actual audio tag is hidden for display
                if (!contentElement) {
                    // console.warn(`Element wrapper ${elementWrapper.id} does not contain a recognized .element-content. Skipping save.`);
                    return;
                }

                const elementState = {
                    id: elementWrapper.id,
                    left: elementWrapper.style.left,
                    top: elementWrapper.style.top,
                    width: elementWrapper.style.width,
                    height: elementWrapper.style.height,
                    rotation: elementWrapper.style.transform,
                    zIndex: elementWrapper.style.zIndex,
                    opacity: contentElement.style.opacity,
                    originalName: elementWrapper.dataset.originalName || '' // Store original name for files
                };

                if (contentElement.tagName === 'IMG') {
                    elementState.type = contentElement.tagName.toLowerCase();
                    elementState.src = contentElement.src;
                } else if (contentElement.tagName === 'AUDIO') { // NEW: Save audio state
                    elementState.type = contentElement.tagName.toLowerCase();
                    elementState.src = contentElement.src;
                    elementState.volume = contentElement.volume;
                    elementState.currentTime = contentElement.currentTime;
                    elementState.paused = contentElement.paused; // Capture current paused state
                    elementState.isPlaying = !contentElement.paused; // Capture if it was playing
                    elementState.duration = contentElement.duration;
                    elementState.lastVolume = contentElement.dataset.lastVolume || 0.5; // Store last unmuted volume
                } else if (contentElement.classList.contains('text-content')) {
                    elementState.type = 'text';
                    elementState.textContent = contentElement.textContent;
                    elementState.color = contentElement.style.color;
                    elementState.backgroundColor = contentElement.style.backgroundColor;
                    elementState.fontSize = contentElement.style.fontSize;
                    elementState.isBold = contentElement.classList.contains('font-bold');
                    elementState.isItalic = contentElement.classList.contains('italic');
                    elementState.outlineThickness = contentElement.style.webkitTextStrokeWidth;
                    elementState.outlineColor = contentElement.style.webkitTextStrokeColor;
                    elementState.hasTextBackground = (contentElement.style.backgroundColor !== 'transparent');
                    elementState.hasTextOutline = (parseFloat(contentElement.style.webkitTextStrokeWidth) > 0);
                } else {
                    console.warn('Unknown element type in saved data:', data.type);
                    return;
                }
                elementsData.push(elementState);
            });
            localStorage.setItem('canvasElements', JSON.stringify(elementsData));
            localStorage.setItem('isMutedGlobally', isMutedGlobally); // Save global mute state
        }

        /**
         * Loads elements from localStorage and recreates them on the canvas.
         * Now, this function is primarily for initial local load if WebSocket is not yet connected
         * or as a fallback. The primary load will come from `initialState` message.
         */
        function loadElementsState() {
            // Retrieve global mute state first
            isMutedGlobally = JSON.parse(localStorage.getItem('isMutedGlobally')) !== false; // Default to true if not found or is null/undefined/false

            const savedElements = localStorage.getItem('canvasElements');
            if (savedElements) {
                const elementsData = JSON.parse(savedElements);
                elementsData.forEach(data => {
                    // Only create if it doesn't already exist from a WebSocket initial state sync
                    if (!allElements.has(data.id)) {
                        createElementFromData(data);
                    }
                });
            }
        }

        /**
         * Helper function to create an elementWrapper and its content based on received data.
         * Used by both initial load and WebSocket updates.
         * @param {Object} data - Element state data.
         */
        function createElementFromData(data) {
            // Check if element already exists to prevent duplicates on redraw/reception
            if (allElements.has(data.id)) {
                // console.log(`Element ${data.id} already exists, attempting to update instead of create.`);
                updateElementFromData(data);
                return;
            }

            const wrapperDiv = document.createElement('div');
            wrapperDiv.id = data.id;
            wrapperDiv.classList.add('element-wrapper');
            if (data.type === 'text') {
                wrapperDiv.classList.add('text-element-wrapper');
            }

            wrapperDiv.style.left = data.left;
            wrapperDiv.style.top = data.top;
            wrapperDiv.style.width = data.width;
            wrapperDiv.style.height = data.height;
            wrapperDiv.style.transform = data.rotation;
            wrapperDiv.style.zIndex = data.zIndex;
            if (data.originalName) {
                wrapperDiv.dataset.originalName = data.originalName;
            }

            let contentElement;
            if (data.type === 'img') {
                contentElement = document.createElement('img');
                contentElement.src = data.src;
                contentElement.alt = data.originalName || 'Image';
                contentElement.classList.add('element-content'); // Add class here
            } else if (data.type === 'audio') { // NEW: Load audio element
                contentElement = document.createElement('audio'); // This is the actual <audio> tag
                contentElement.src = data.src;
                contentElement.volume = data.volume || 0.5;
                contentElement.currentTime = data.currentTime || 0;
                contentElement.dataset.lastVolume = data.lastVolume || 0.5; // Store last unmuted volume
                contentElement.muted = data.muted || isMutedGlobally; // Apply initial mute state
                contentElement.classList.add('element-content'); // Add class here
                contentElement.classList.add('hidden'); // Hide the default audio controls

                // Add event listener for when metadata is loaded to get duration
                contentElement.addEventListener('loadedmetadata', () => {
                    // Only update duration if it's not already set or is NaN
                    if (isNaN(contentElement.duration)) {
                        contentElement.duration = data.duration || contentElement.duration; // Restore duration
                    }
                    updateTimelineDisplay(contentElement);
                });
                // Add event listener for time updates
                contentElement.addEventListener('timeupdate', () => {
                    // Only update if this audio is currently selected OR if there's no selected element
                    // This prevents sliders jumping around if other audio is playing in the background
                    if (selectedElementWrapper && selectedElementWrapper.id === wrapperDiv.id) {
                        updateTimelineDisplay(contentElement);
                    }
                });
                contentElement.addEventListener('ended', () => {
                    if (selectedElementWrapper && selectedElementWrapper.id === wrapperDiv.id) {
                        updatePlayPauseButton(true); // Set to play icon
                        contentElement.currentTime = 0; // Reset to start
                        timelineRange.value = 0; // Reset timeline slider
                        currentTimeDisplay.textContent = formatTime(0) + ' / ' + formatTime(contentElement.duration || 0);
                    }
                });

                // Create the visual icon for audio
                const audioIcon = document.createElement('div');
                audioIcon.classList.add('audio-visual-icon', 'flex', 'items-center', 'justify-center', 'text-gray-400', 'text-2xl', 'h-full', 'w-full'); // Renamed class
                audioIcon.innerHTML = `
                    <!-- Simple speaker icon SVG -->
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-8 h-8">
                        <path d="M18.5 12c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM5 10v4h3l4 4V6l-4 4H5z"/>
                    </svg>
                `;
                wrapperDiv.appendChild(audioIcon); // Append the visual icon first
                wrapperDiv.appendChild(contentElement); // Then append the actual audio tag
            } else if (data.type === 'text') {
                contentElement = document.createElement('div');
                contentElement.classList.add('text-content');
                contentElement.classList.add('element-content'); // Add class here
                contentElement.contentEditable = true;
                contentElement.textContent = data.textContent;
                contentElement.style.color = data.color;
                contentElement.style.backgroundColor = data.backgroundColor;
                contentElement.style.fontSize = data.fontSize;
                contentElement.spellcheck = false;

                if (data.isBold) contentElement.classList.add('font-bold');
                if (data.isItalic) contentElement.classList.add('italic');

                if (data.hasTextOutline && parseFloat(data.outlineThickness) > 0) {
                    contentElement.style.webkitTextStrokeWidth = data.outlineThickness;
                    contentElement.style.webkitTextStrokeColor = data.outlineColor;
                    contentElement.style.textShadow = generateTextShadowForOutline(parseFloat(data.outlineThickness), data.outlineColor);
                } else {
                    contentElement.style.webkitTextStrokeWidth = '0';
                    contentElement.style.webkitTextStrokeColor = 'transparent';
                    contentElement.style.textShadow = 'none';
                }
            } else {
                console.warn('Unknown element type in saved data (only image/text/audio expected):', data.type);
                return; // Skip unsupported types
            }
            
            contentElement.style.opacity = data.opacity; // Apply opacity to the actual content element

            if (data.type !== 'audio') { // Only append if not already handled for audio
                 wrapperDiv.appendChild(contentElement);
            }
           
            addHandles(wrapperDiv);

            mainCanvasWrapper.appendChild(wrapperDiv);
            allElements.set(wrapperDiv.id, wrapperDiv);

            if (data.type === 'text') {
                adjustTextElementWrapperSize(wrapperDiv);
            }
            // If audio was playing when saved, attempt to resume playback (browser permitting)
            // Only if not globally muted
            if (data.type === 'audio' && data.isPlaying && !isMutedGlobally) {
                contentElement.play().catch(e => {
                    console.warn('Autoplay blocked for loaded audio on page load:', e);
                    // It's common for browsers to block autoplay with sound without user interaction.
                    // The user might need to manually click the play button after refresh.
                });
            }
        }

        /**
         * Helper function to update an existing elementWrapper and its content based on received data.
         * Used by WebSocket updates.
         * @param {Object} data - Element state data.
         */
        function updateElementFromData(data) {
            const elementWrapper = allElements.get(data.id);
            if (!elementWrapper) {
                // console.warn(`Element ${data.id} not found for update, creating instead.`);
                createElementFromData(data); // If not found, create it
                return;
            }

            // Update wrapper styles
            elementWrapper.style.left = data.left;
            elementWrapper.style.top = data.top;
            elementWrapper.style.width = data.width;
            elementWrapper.style.height = data.height;
            elementWrapper.style.transform = data.rotation;
            elementWrapper.style.zIndex = data.zIndex;
            elementWrapper.dataset.originalName = data.originalName || '';

            const contentElement = elementWrapper.querySelector('img.element-content, audio.element-content, div.text-content.element-content');
            if (!contentElement) {
                console.error(`Content element not found inside wrapper ${data.id} for update.`);
                return;
            }
            contentElement.style.opacity = data.opacity;

            if (data.type === 'img') {
                // No specific update logic needed for img src unless it changes
            } else if (data.type === 'audio') {
                // Update audio specific properties
                if (contentElement.src !== data.src) { // Only update src if it changed to prevent unnecessary reloads
                    contentElement.src = data.src;
                    contentElement.load(); // Reload audio if src changed
                }
                contentElement.volume = data.volume;
                contentElement.currentTime = data.currentTime;
                contentElement.dataset.lastVolume = data.lastVolume;
                contentElement.muted = data.muted || isMutedGlobally; // Respect global mute state

                // Handle play/pause state
                if (data.isPlaying && contentElement.paused && !isMutedGlobally) {
                    contentElement.play().catch(e => console.warn('Autoplay blocked during update:', e));
                } else if (!data.isPlaying && !contentElement.paused) {
                    contentElement.pause();
                }

                // If the updated element is currently selected, refresh its controls
                // This part now executes regardless of local selection.
                if (selectedElementWrapper && selectedElementWrapper.id === data.id) {
                    volumeRange.value = contentElement.volume;
                    volumeValueDisplay.textContent = `${Math.round(contentElement.volume * 100)}%`;
                    updatePlayPauseButton(contentElement.paused);
                    updateTimelineDisplay(contentElement);
                }
            } else if (data.type === 'text') {
                // Update text specific properties
                contentElement.textContent = data.textContent;
                contentElement.style.color = data.color;
                contentElement.style.backgroundColor = data.backgroundColor;
                contentElement.style.fontSize = data.fontSize;

                if (data.isBold) contentElement.classList.add('font-bold');
                else contentElement.classList.remove('font-bold');

                if (data.isItalic) contentElement.classList.add('italic');
                else contentElement.classList.remove('italic');

                if (data.hasTextOutline && parseFloat(data.outlineThickness) > 0) {
                    contentElement.style.webkitTextStrokeWidth = data.outlineThickness;
                    contentElement.style.webkitTextStrokeColor = data.outlineColor;
                    contentElement.style.textShadow = generateTextShadowForOutline(parseFloat(data.outlineThickness), data.outlineColor);
                } else {
                    contentElement.style.webkitTextStrokeWidth = '0';
                    contentElement.style.webkitTextStrokeColor = 'transparent';
                    contentElement.style.textShadow = 'none';
                }

                adjustTextElementWrapperSize(elementWrapper); // Re-adjust size after text changes

                // If the updated element is currently selected, refresh its controls
                // This part now executes regardless of local selection.
                if (selectedElementWrapper && selectedElementWrapper.id === data.id) {
                    textInput.value = data.textContent;
                    textColorInput.value = data.color;
                    textBgColorInput.value = data.backgroundColor;
                    toggleTextBg.checked = data.hasTextBackground;
                    // Trigger change event for the background toggle to update its disabled state
                    const event = new Event('change');
                    toggleTextBg.dispatchEvent(event);

                    toggleTextOutline.checked = data.hasTextOutline;
                    textOutlineColorInput.value = data.outlineColor;
                    outlineThicknessRange.value = parseFloat(data.outlineThickness);
                    outlineThicknessValue.textContent = `${outlineThicknessRange.value}px`;
                    // Trigger change event for the outline toggle to update its disabled state
                    toggleTextOutline.dispatchEvent(event);

                    fontSizeRange.value = parseFloat(data.fontSize);
                    fontSizeValue.textContent = `${fontSizeRange.value}px`;

                    if (data.isBold) boldTextBtn.classList.add('active-style');
                    else boldTextBtn.classList.remove('active-style');

                    if (data.isItalic) italicTextBtn.classList.add('active-style');
                    else italicTextBtn.classList.remove('active-style');
                }
            }
            // If the updated element is currently selected, re-select it to refresh UI
            // This will ensure the handles and UI controls reflect the latest state.
            if (selectedElementWrapper && selectedElementWrapper.id === data.id) {
                selectElement(elementWrapper);
            }
        }

        /**
         * Helper function to delete an element from the DOM and allElements Map.
         * Used by WebSocket updates.
         * @param {string} elementId - The ID of the element to delete.
         */
        function deleteElementFromData(elementId) {
            const elementWrapper = allElements.get(elementId);
            if (elementWrapper) {
                const contentElement = elementWrapper.querySelector('.element-content');
                if (contentElement && contentElement.tagName === 'AUDIO') {
                    contentElement.pause(); // Pause audio before removing
                    contentElement.src = ''; // Clear source to release resources
                    contentElement.load(); // Load an empty source to fully release
                }
                allElements.delete(elementId);
                elementWrapper.remove();
                if (selectedElementWrapper && selectedElementWrapper.id === elementId) {
                    deselectAllElements(); // Deselect if the deleted element was selected
                }
            }
        }


        /**
         * Updates the play/pause button icon based on the paused state.
         * @param {boolean} isPaused - True if the audio/video is paused, false otherwise.
         */
        function updatePlayPauseButton(isPaused) {
            if (isPaused) {
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
            } else {
                playIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
            }
        }

        /**
         * Updates the timeline display for audio elements.
         * @param {HTMLAudioElement} audioElement - The audio element.
         */
        function updateTimelineDisplay(audioElement) {
            if (!isNaN(audioElement.duration)) {
                timelineRange.max = audioElement.duration;
                timelineRange.value = audioElement.currentTime;
                currentTimeDisplay.textContent = `${formatTime(audioElement.currentTime)} / ${formatTime(audioElement.duration)}`;
            } else {
                // If duration is not available yet, display loading state
                currentTimeDisplay.textContent = `0:00 / 0:00`;
            }
        }

        /**
         * Applies the global mute state to all audio elements and updates the UI of the global mute button.
         */
        function applyGlobalMuteState() {
            allElements.forEach(elementWrapper => {
                const audioElement = elementWrapper.querySelector('audio.element-content');
                if (audioElement) {
                    audioElement.muted = isMutedGlobally;
                    if (isMutedGlobally) {
                        // When globally muted, effectively set volume to 0 for playback, but preserve lastVolume
                        // to restore when unmuted. Actual audio.volume should be 0.
                        audioElement.volume = 0;
                        if (!audioElement.paused) { // If playing when muted, pause it
                            audioElement.pause();
                            if (selectedElementWrapper && selectedElementWrapper.id === elementWrapper.id) {
                                updatePlayPauseButton(true);
                            }
                        }
                    } else {
                        // When unmuted, restore volume from dataset.lastVolume or default 0.5
                        audioElement.volume = parseFloat(audioElement.dataset.lastVolume || 0.5);
                    }
                }
            });

            // Update the global mute button UI
            if (isMutedGlobally) {
                volumeOnIcon.classList.add('hidden');
                volumeOffIcon.classList.remove('hidden');
                muteButtonText.textContent = 'Activar sonido';
            } else {
                volumeOnIcon.classList.remove('hidden');
                volumeOffIcon.classList.add('hidden');
                muteButtonText.textContent = 'Silenciar página';
            }

            // Update the selected audio element's volume slider if it's currently selected
            if (selectedElementWrapper) {
                const selectedAudio = selectedElementWrapper.querySelector('audio.element-content');
                if (selectedAudio) {
                    volumeRange.value = selectedAudio.volume;
                    volumeValueDisplay.textContent = `${Math.round(selectedAudio.volume * 100)}%`;
                }
            }
            saveElementsState(); // Save global mute state when it changes
        }


        function deselectAllElements() {
            // This function now only deselects visual elements and disables controls,
            // it no longer pauses or mutes audio elements automatically.
            document.querySelectorAll('.element-wrapper').forEach(el => {
                el.classList.remove('selected');
                el.querySelectorAll('.resize-handle').forEach(handle => handle.style.display = 'none');
                el.querySelector('.rotation-handle').style.display = 'none'; // Hide rotation handle
            });
            document.querySelectorAll('.layer-item').forEach(item => item.classList.remove('selected'));

            selectedElementWrapper = null;
            opacityRange.value = 1;
            opacityValue.textContent = '100%';
            rotationRange.value = 0;
            rotationValue.textContent = '0°';

            // Disable general controls (since no element is selected)
            opacityRange.disabled = true;
            rotationRange.disabled = true;
            duplicateElementBtn.disabled = true;
            deleteElementBtn.disabled = true;
            resetOpacityBtn.disabled = true;
            resetRotationBtn.disabled = true;
            bringToFrontBtn.disabled = true;

            // Text input is always enabled for new text entry
            textInput.disabled = false;
            // Set default values for new text and enable them
            textColorInput.value = '#FFFFFF'; // Default white text color
            textBgColorInput.value = '#000000'; // Default black background color
            toggleTextBg.checked = false; // Default to background DISABLED for new text
            
            // Outline controls
            toggleTextOutline.checked = false; // Default to outline DISABLED for new text
            textOutlineColorInput.value = '#000000'; // Default black outline color
            outlineThicknessRange.value = 0;
            outlineThicknessValue.textContent = '0px';

            // Font size controls
            fontSizeRange.value = 24; // Default font size
            fontSizeValue.textContent = '24px';


            boldTextBtn.classList.remove('active-style'); // Ensure button is not active
            italicTextBtn.classList.remove('active-style'); // Ensure button is not active

            // Enable text styling controls by default for new text creation
            textColorInput.disabled = false;
            boldTextBtn.disabled = false;
            italicTextBtn.disabled = false;
            toggleTextBg.disabled = false; // Enable toggle for new text
            toggleTextOutline.disabled = false; // Enable toggle for new text
            fontSizeRange.disabled = false; // Enable font size for new text

            // Also manage the disabled state of textBgColorInput based on toggleTextBg
            textBgColorInput.disabled = !toggleTextBg.checked;
            textOutlineColorInput.disabled = !toggleTextOutline.checked;
            outlineThicknessRange.disabled = !toggleTextOutline.checked;

            // Update label colors for disabled state
            textBgColorLabel.classList.add('text-gray-600');
            textBgColorLabel.classList.remove('text-gray-300');
            textOutlineColorLabel.classList.add('text-gray-600');
            textOutlineColorLabel.classList.remove('text-gray-300');
            outlineThicknessLabel.classList.add('text-gray-600');
            outlineThicknessLabel.classList.remove('text-gray-300');

            // Disable audio controls (but don't affect playback state)
            playPauseBtn.disabled = true;
            volumeRange.disabled = true;
            timelineRange.disabled = true;
            // No changes to volume/timeline values, they reflect the last selected audio or default.
            // No changes to play/pause button icon, it will reflect the last selected audio.
        }

        function selectElement(elementWrapper) {
            // Get the currently selected content element (if any)
            let currentSelectedContentElement = null;
            if (selectedElementWrapper) {
                currentSelectedContentElement = selectedElementWrapper.querySelector('img.element-content, audio.element-content, div.text-content.element-content');
            }

            // If the previously selected element was audio, and the newly selected is *different audio*
            // pause the previously playing audio to avoid overlapping, maintaining single active audio control model.
            if (currentSelectedContentElement && currentSelectedContentElement.tagName === 'AUDIO' &&
                elementWrapper.querySelector('audio.element-content') && 
                currentSelectedContentElement !== elementWrapper.querySelector('audio.element-content')) {
                
                currentSelectedContentElement.pause();
                currentSelectedContentElement.muted = true; // Mute the previously playing audio
            }

            deselectAllElements(); // Deselects current, sets default states for ALL controls

            selectedElementWrapper = elementWrapper;
            selectedElementWrapper.classList.add('selected');
            selectedElementWrapper.querySelector('.rotation-handle').style.display = 'block';

            // IMPORTANT: Now specifically query for the actual content element using its tag and the .element-content class
            const contentElement = selectedElementWrapper.querySelector('img.element-content, audio.element-content, div.text-content.element-content');

            // If for some reason contentElement is null, log and return to prevent errors
            if (!contentElement) {
                console.error("Could not find content element for selected wrapper:", selectedElementWrapper.id);
                return;
            }

            // Only show resize handles if it's NOT a text or audio element
            if (!contentElement.classList.contains('text-content') && contentElement.tagName !== 'AUDIO') {
                selectedElementWrapper.querySelectorAll('.resize-handle').forEach(handle => handle.style.display = 'block');
            }


            // Enable general controls
            opacityRange.disabled = false;
            rotationRange.disabled = false;
            duplicateElementBtn.disabled = false;
            deleteElementBtn.disabled = false;
            resetOpacityBtn.disabled = false;
            resetRotationBtn.disabled = false;
            bringToFrontBtn.disabled = false;

            // Update sidebar controls based on selected element
            opacityRange.value = parseFloat(contentElement.style.opacity) || 1;
            opacityValue.textContent = `${Math.round(opacityRange.value * 100)}%`;
            rotationRange.value = getRotation(selectedElementWrapper) || 0;
            rotationValue.textContent = `${Math.round(rotationRange.value)}°`;


            if (contentElement.classList.contains('text-content')) {
                // Text element selected: enable text controls and reflect its style
                textInput.disabled = false;
                textInput.value = contentElement.textContent;

                textColorInput.disabled = false;
                boldTextBtn.disabled = false;
                italicTextBtn.disabled = false;
                toggleTextBg.disabled = false; // Enable toggle for text selection
                toggleTextOutline.disabled = false; // Enable toggle for text selection
                fontSizeRange.disabled = false; // Enable font size for text selection

                textColorInput.value = contentElement.style.color || '#FFFFFF'; // Default to white if not set

                // Check background status for toggle
                if (contentElement.style.backgroundColor === 'transparent') {
                    toggleTextBg.checked = false;
                    textBgColorInput.value = '#000000'; // Show default black in picker when transparent
                    textBgColorInput.disabled = true; // Disable color picker if transparent
                    textBgColorLabel.classList.add('text-gray-600'); // Set label to gray
                    textBgColorLabel.classList.remove('text-gray-300'); // Remove active color
                } else {
                    toggleTextBg.checked = true;
                    textBgColorInput.value = contentElement.style.backgroundColor || '#000000'; // Default to black if not set
                    textBgColorInput.disabled = false; // Enable color picker if background is active
                    textBgColorLabel.classList.remove('text-gray-600'); // Set label to active color
                    textBgColorLabel.classList.add('text-gray-300');
                }

                // Check outline status for toggle
                // Now retrieve thickness and color from controls directly for display consistency
                const currentOutlineThickness = outlineThicknessRange.value;
                const currentOutlineColor = textOutlineColorInput.value;

                if (contentElement.style.webkitTextStrokeWidth && parseFloat(contentElement.style.webkitTextStrokeWidth) > 0) {
                    toggleTextOutline.checked = true;
                    textOutlineColorInput.value = contentElement.style.webkitTextStrokeColor || '#000000';
                    outlineThicknessRange.value = parseFloat(contentElement.style.webkitTextStrokeWidth);
                    outlineThicknessValue.textContent = `${outlineThicknessRange.value}px`;
                    textOutlineColorInput.disabled = false;
                    outlineThicknessRange.disabled = false;
                    textOutlineColorLabel.classList.remove('text-gray-600');
                    textOutlineColorLabel.classList.add('text-gray-300');
                    outlineThicknessLabel.classList.remove('text-gray-600');
                    outlineThicknessLabel.classList.add('text-gray-300');
                } else {
                    toggleTextOutline.checked = false;
                    textOutlineColorInput.value = '#000000';
                    outlineThicknessRange.value = 0;
                    outlineThicknessValue.textContent = '0px';
                    textOutlineColorInput.disabled = true;
                    outlineThicknessRange.disabled = true;
                    textOutlineColorLabel.classList.add('text-gray-600');
                    textOutlineColorLabel.classList.remove('text-gray-300');
                    outlineThicknessLabel.classList.add('text-gray-600');
                    outlineThicknessLabel.classList.remove('text-gray-300');
                }

                // Update font size controls
                fontSizeRange.value = parseFloat(contentElement.style.fontSize) || 24;
                fontSizeValue.textContent = `${fontSizeRange.value}px`;


                if (contentElement.classList.contains('font-bold')) {
                    boldTextBtn.classList.add('active-style');
                } else {
                    boldTextBtn.classList.remove('active-style');
                }
                if (contentElement.classList.contains('italic')) {
                    italicTextBtn.classList.add('active-style');
                } else {
                    italicTextBtn.classList.remove('active-style');
                }
                
                // After setting text content and applying styles, adjust wrapper size
                // This must be called after all text properties are set
                adjustTextElementWrapperSize(selectedElementWrapper);

            } else if (contentElement.tagName === 'IMG') {
                // Image selected
                textInput.value = ''; // Clear text input for new text
            } else if (contentElement.tagName === 'AUDIO') { // NEW: Audio element selected
                // Activate audio controls
                playPauseBtn.disabled = false;
                volumeRange.disabled = false;
                timelineRange.disabled = false;

                // Set audio properties to controls
                contentElement.muted = isMutedGlobally; // Ensure it respects global mute on selection
                volumeRange.value = contentElement.volume;
                volumeValueDisplay.textContent = `${Math.round(contentElement.volume * 100)}%`;
                updatePlayPauseButton(contentElement.paused);
                updateTimelineDisplay(contentElement);

                // Hide resize handles for audio elements as they don't have visual dimensions
                selectedElementWrapper.querySelectorAll('.resize-handle').forEach(handle => handle.style.display = 'none');
            }

            // Select layer item
            const layerItem = document.querySelector(`.layer-item[data-id="${elementWrapper.id}"]`);
            if (layerItem) {
                layerItem.classList.add('selected');
            }
        }

        function getRotation(element) {
            const transform = element.style.transform;
            const match = transform.match(/rotate\(([-?\d.]+)deg\)/);
            return match ? parseFloat(match[1]) : 0;
        }

        function addHandles(elementWrapper) {
            // Add resize handles
            const handles = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
            handles.forEach(pos => {
                const handle = document.createElement('div');
                handle.classList.add('resize-handle', pos);
                handle.style.display = 'none';
                elementWrapper.appendChild(handle);
            });

            // Add rotation handle
            const rotationHandle = document.createElement('div');
            rotationHandle.classList.add('rotation-handle');
            rotationHandle.style.display = 'none';
            elementWrapper.appendChild(rotationHandle);
        }

        function updateLayersList() {
            layersList.innerHTML = '';
            if (allElements.size === 0) {
                layersList.innerHTML = '<p class="text-gray-400 text-sm">No hay elementos en la página.</p>';
                return;
            }

            // Sort elements by z-index to display layers correctly (highest z-index at the top)
            const sortedElements = Array.from(allElements.values()).sort((a, b) => {
                return (parseFloat(b.style.zIndex || 0)) - (parseFloat(a.style.zIndex || 0));
            });

            sortedElements.forEach(elementWrapper => {
                // Get the actual content element for display name
                const contentElement = elementWrapper.querySelector('img.element-content, audio.element-content, div.text-content.element-content');
                
                const layerItem = document.createElement('div');
                layerItem.classList.add('layer-item');
                layerItem.dataset.id = elementWrapper.id;

                let name;
                if (contentElement && contentElement.tagName === 'IMG') {
                    name = `Imagen: "${elementWrapper.dataset.originalName || contentElement.alt || elementWrapper.id}"`;
                } else if (contentElement && contentElement.classList.contains('text-content')) {
                    name = `Texto: "${contentElement.textContent.substring(0, 20)}${contentElement.textContent.length > 20 ? '...' : ''}"`;
                } else if (contentElement && contentElement.tagName === 'AUDIO') {
                    name = `Audio: "${elementWrapper.dataset.originalName || 'Audio'}"`;
                } else {
                    name = `Elemento desconocido: ${elementWrapper.id}`;
                }
                layerItem.textContent = name;

                if (selectedElementWrapper && selectedElementWrapper.id === elementWrapper.id) {
                    layerItem.classList.add('selected');
                }
                layerItem.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectElement(elementWrapper);
                });

                // Add drag handles for reordering layers
                const dragHandle = document.createElement('span');
                dragHandle.innerHTML = '&#9776;'; // Hamburger icon
                dragHandle.classList.add('drag-handle', 'mr-2', 'cursor-move', 'text-gray-400', 'hover:text-white');
                dragHandle.setAttribute('draggable', 'true');
                layerItem.prepend(dragHandle); // Add handle at the beginning

                layersList.appendChild(layerItem);
            });
        }

        function updateFileCountDisplay() {
            fileCountDisplay.textContent = `${allElements.size}/${fileLimit}`;
            if (allElements.size >= fileLimit) {
                imageUpload.disabled = true;
                // Since we're using a custom button, we might want to disable that visual button
                imageUpload.parentElement.classList.add('opacity-50', 'cursor-not-allowed');
                imageUpload.parentElement.style.pointerEvents = 'none'; // Make it truly non-clickable
                selectFileButtonText.textContent = 'Límite alcanzado'; // Change button text
                imageUpload.parentElement.classList.remove('hover:bg-purple-700');
                dropArea.classList.add('opacity-50', 'cursor-not-allowed');
                dropArea.style.pointerEvents = 'none';
            } else {
                imageUpload.disabled = false;
                imageUpload.parentElement.classList.remove('opacity-50', 'cursor-not-allowed');
                imageUpload.parentElement.style.pointerEvents = 'auto';
                selectFileButtonText.textContent = 'Seleccionar archivo'; // Restore original button text
                imageUpload.parentElement.classList.add('hover:bg-purple-700');
                dropArea.classList.remove('opacity-50', 'cursor-not-allowed');
                dropArea.style.pointerEvents = 'auto';
            }
        }

        // --- Event Handlers ---

        // Handle image/GIF/MP3 upload
        // This function will be called by both file input change and drag-and-drop
        function handleFile(file) {
            if (allElements.size >= fileLimit) {
                console.warn(`Se ha alcanzado el límite de carga de archivos (${fileLimit} archivos).`);
                return;
            }

            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const wrapperDiv = document.createElement('div');
                    wrapperDiv.id = generateUniqueId();
                    wrapperDiv.classList.add('element-wrapper');
                    
                    // Position new elements in the center of the green canvas
                    const greenCanvasCenterX = leftSidebar.offsetWidth / 2;
                    const greenCanvasCenterY = leftSidebar.offsetHeight / 2;

                    // Default size for a newly added wrapper, can be adjusted later by content
                    const initialWrapperWidth = 100; 
                    const initialWrapperHeight = 100; 

                    const initialLeft = greenCanvasCenterX - (initialWrapperWidth / 2);
                    const initialTop = greenCanvasCenterY - (initialWrapperHeight / 2);

                    wrapperDiv.style.left = `${initialLeft}px`;
                    wrapperDiv.style.top = `${initialTop}px`;

                    wrapperDiv.style.minWidth = '50px';
                    wrapperDiv.style.minHeight = '30px';
                    wrapperDiv.style.zIndex = getNextHighestZIndex(); // New elements come on top
                    wrapperDiv.style.transform = 'rotate(0deg)';

                    let elementState = {
                        id: wrapperDiv.id,
                        left: wrapperDiv.style.left,
                        top: wrapperDiv.style.top,
                        width: wrapperDiv.style.width,
                        height: wrapperDiv.style.height,
                        rotation: wrapperDiv.style.transform,
                        zIndex: wrapperDiv.style.zIndex,
                        opacity: '1',
                        originalName: file.name
                    };

                    let contentElement; // This variable will hold the actual img, audio, or text div
                    if (file.type.startsWith('image/')) {
                        contentElement = document.createElement('img');
                        contentElement.src = e.target.result;
                        contentElement.alt = file.name;
                        wrapperDiv.dataset.originalName = file.name; // Store original file name
                        wrapperDiv.style.width = '100px'; // Initial small width for images (unscaled)
                        wrapperDiv.style.height = 'auto'; // Auto height to maintain aspect ratio (unscaled)
                        contentElement.classList.add('element-content'); // Mark as content
                        wrapperDiv.appendChild(contentElement); // Append image directly
                        contentElement.style.opacity = '1';
                        contentElement.onload = () => {
                            // Adjust wrapper height after image loads to fit content (unscaled)
                            wrapperDiv.style.height = `${contentElement.offsetHeight}px`; 
                            // After initial size adjustment, send update.
                            // Capture the state after the image has loaded and dimensions are set
                            const updatedElementState = {
                                ...elementState,
                                width: wrapperDiv.style.width,
                                height: wrapperDiv.style.height
                            };
                            sendWebSocketMessage('elementUpdate', { element: updatedElementState });
                            saveElementsState(); // Save to local storage as well
                        };
                        elementState.type = 'img';
                        elementState.src = e.target.result;

                    } else if (file.type.startsWith('audio/')) { // NEW: Handle audio files
                        contentElement = document.createElement('audio'); // This is the actual <audio> tag
                        contentElement.src = e.target.result;
                        contentElement.volume = 0.5; // Default volume
                        contentElement.dataset.lastVolume = 0.5; // Initial last volume
                        contentElement.muted = isMutedGlobally; // Apply global mute state
                        contentElement.classList.add('hidden'); // Hide the default audio controls
                        contentElement.classList.add('element-content'); // Mark as content
                        wrapperDiv.dataset.originalName = file.name; // Store original file name
                        
                        // For audio, set a fixed small size for its visual representation on canvas
                        wrapperDiv.style.width = '50px'; 
                        wrapperDiv.style.height = '50px';

                        // Add a visual indicator for audio element (e.g., a speaker icon)
                        const audioIcon = document.createElement('div');
                        audioIcon.classList.add('audio-visual-icon', 'flex', 'items-center', 'justify-center', 'text-gray-400', 'text-2xl', 'h-full', 'w-full'); // Renamed class
                        audioIcon.innerHTML = `
                            <!-- Simple speaker icon SVG -->
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-8 h-8">
                                <path d="M18.5 12c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM5 10v4h3l4 4V6l-4 4H5z"/>
                            </svg>
                        `;
                        wrapperDiv.appendChild(audioIcon); // Append the visual icon first
                        wrapperDiv.appendChild(contentElement); // Then append the actual audio tag
                        contentElement.style.opacity = '1';

                        // Add event listeners for the audio element
                        contentElement.addEventListener('timeupdate', () => {
                            if (selectedElementWrapper && selectedElementWrapper.id === wrapperDiv.id) {
                                updateTimelineDisplay(contentElement);
                            }
                        });
                        contentElement.addEventListener('ended', () => {
                            if (selectedElementWrapper && selectedElementWrapper.id === wrapperDiv.id) {
                                updatePlayPauseButton(true); // Set to play icon
                                contentElement.currentTime = 0; // Reset to start
                                timelineRange.value = 0; // Reset timeline slider
                                currentTimeDisplay.textContent = formatTime(0) + ' / ' + formatTime(contentElement.duration || 0);
                            }
                        });
                        contentElement.addEventListener('loadedmetadata', () => {
                            updateTimelineDisplay(contentElement); // Update display once duration is known
                            // Send update after duration is known (if needed for shared state)
                            const updatedElementState = {
                                ...elementState,
                                duration: contentElement.duration
                            };
                            sendWebSocketMessage('elementUpdate', { element: updatedElementState });
                        });
                        elementState.type = 'audio';
                        elementState.src = e.target.result;
                        elementState.volume = contentElement.volume;
                        elementState.currentTime = contentElement.currentTime;
                        elementState.paused = contentElement.paused;
                        elementState.isPlaying = !contentElement.paused;
                        elementState.duration = contentElement.duration;
                        elementState.lastVolume = contentElement.dataset.lastVolume;

                    } else {
                        console.warn('Tipo de archivo no admitido (solo se esperan imágenes/gif/mp3):', file.type);
                        return; // Skip unsupported files
                    }
                    
                    addHandles(wrapperDiv);

                    // Elements are now appended to mainCanvasWrapper
                    mainCanvasWrapper.appendChild(wrapperDiv);
                    allElements.set(wrapperDiv.id, wrapperDiv);
                    updateLayersList();
                    updateFileCountDisplay(); // Update counter
                    
                    sendWebSocketMessage('elementAdd', { element: elementState });
                    saveElementsState(); // Save state after adding new element
                };
                reader.readAsDataURL(file);
            }
        }

        imageUpload.addEventListener('change', (event) => {
            if (event.target.files.length > 0) {
                handleFile(event.target.files[0]);
                event.target.value = ''; // Clear the selected file in input
            }
        });

        // Handle adding text
        addTextBtn.addEventListener('click', () => {
            if (allElements.size >= fileLimit) {
                console.warn(`Se ha alcanzado el límite de carga de archivos (${fileLimit} archivos).`);
                return;
            }

            const textContent = textInput.value.trim() === '' ? 'Nuevo Texto' : textInput.value;

            const wrapperDiv = document.createElement('div');
            wrapperDiv.id = generateUniqueId();
            wrapperDiv.classList.add('element-wrapper', 'text-element-wrapper'); // Add text-element-wrapper class
            
            // Position new elements in the center of the green canvas
            const greenCanvasCenterX = leftSidebar.offsetWidth / 2;
            const greenCanvasCenterY = leftSidebar.offsetHeight / 2;

            const initialLeft = greenCanvasCenterX - (100 / 2); // Default width 100
            const initialTop = greenCanvasCenterY - (50 / 2);   // Default height 50

            wrapperDiv.style.left = `${initialLeft}px`;
            wrapperDiv.style.top = `${initialTop}px`;

            wrapperDiv.style.minWidth = '50px';
            wrapperDiv.style.minHeight = '30px';
            wrapperDiv.style.zIndex = getNextHighestZIndex(); // New elements come on top
            wrapperDiv.style.transform = 'rotate(0deg)';
            // Set width and height to 'auto' for text elements to allow self-sizing (unscaled)
            // These will be explicitly set by adjustTextElementWrapperSize after content is added
            wrapperDiv.style.width = 'auto';
            wrapperDiv.style.height = 'auto';

            wrapperDiv.dataset.originalName = 'Text Element'; // Store a generic name for text elements

            const textDiv = document.createElement('div');
            textDiv.classList.add('element-content', 'text-content', 'text-lg'); // Add element-content here
            textDiv.contentEditable = true;
            textDiv.textContent = textContent;
            textDiv.style.opacity = '1';
            textDiv.spellcheck = false; // Disable spellcheck for text elements

            // Apply current text styling from controls
            textDiv.style.color = textColorInput.value;
            textDiv.style.webkitTextFillColor = textColorInput.value; // For webkit browsers with text-stroke
            textDiv.style.fontSize = `${fontSizeRange.value}px`;

            // Apply background based on toggle state
            if (toggleTextBg.checked) {
                textDiv.style.backgroundColor = textBgColorInput.value;
            } else {
                textDiv.style.backgroundColor = 'transparent';
            }

            // Apply text outline based on toggle and values
            if (toggleTextOutline.checked) {
                const thickness = outlineThicknessRange.value;
                const color = textOutlineColorInput.value;
                textDiv.style.webkitTextStrokeWidth = `${thickness}px`;
                textDiv.style.webkitTextStrokeColor = color;
                textDiv.style.textShadow = generateTextShadowForOutline(thickness, color);
            } else {
                textDiv.style.webkitTextStrokeWidth = '0';
                textDiv.style.webkitTextStrokeColor = 'transparent';
                textDiv.style.textShadow = 'none';
            }

            // Apply bold/italic based on active-style class on buttons
            if (boldTextBtn.classList.contains('active-style')) {
                textDiv.classList.add('font-bold');
            }
            if (italicTextBtn.classList.contains('active-style')) {
                textDiv.classList.add('italic');
            }

            wrapperDiv.appendChild(textDiv);
            addHandles(wrapperDiv);

            // Elements are now appended to mainCanvasWrapper
            mainCanvasWrapper.appendChild(wrapperDiv);
            allElements.set(wrapperDiv.id, wrapperDiv);
            
            // Adjust wrapper size after content is in the DOM and rendered
            adjustTextElementWrapperSize(wrapperDiv);

            textDiv.focus();
            updateLayersList();
            updateFileCountDisplay(); // Update counter

            // Capture initial state of the new text element
            const elementState = {
                id: wrapperDiv.id,
                left: wrapperDiv.style.left,
                top: wrapperDiv.style.top,
                width: wrapperDiv.style.width,
                height: wrapperDiv.style.height,
                rotation: wrapperDiv.style.transform,
                zIndex: wrapperDiv.style.zIndex,
                opacity: textDiv.style.opacity,
                originalName: wrapperDiv.dataset.originalName,
                type: 'text',
                textContent: textDiv.textContent,
                color: textDiv.style.color,
                backgroundColor: textDiv.style.backgroundColor,
                fontSize: textDiv.style.fontSize,
                isBold: textDiv.classList.contains('font-bold'),
                isItalic: textDiv.classList.contains('italic'),
                outlineThickness: textDiv.style.webkitTextStrokeWidth,
                outlineColor: textDiv.style.webkitTextStrokeColor,
                hasTextBackground: (textDiv.style.backgroundColor !== 'transparent'),
                hasTextOutline: (parseFloat(textDiv.style.webkitTextStrokeWidth) > 0)
            };
            sendWebSocketMessage('elementAdd', { element: elementState });
            saveElementsState(); // Save state after adding new element
        });

        // Sync text input with selected text element
        textInput.addEventListener('input', () => {
            if (selectedElementWrapper) {
                const contentElement = selectedElementWrapper.querySelector('.element-content');
                if (contentElement && contentElement.classList.contains('text-content')) {
                    contentElement.textContent = textInput.value;
                    // Adjust wrapper size after text content changes
                    adjustTextElementWrapperSize(selectedElementWrapper);
                    updateLayersList(); // Update layer name if text content changes
                    
                    // Send update to server
                    const elementState = {
                        id: selectedElementWrapper.id,
                        textContent: contentElement.textContent,
                        // Include other properties that might have changed due to text update
                        width: selectedElementWrapper.style.width,
                        height: selectedElementWrapper.style.height
                    };
                    sendWebSocketMessage('elementUpdate', { element: { ...getElementState(selectedElementWrapper), ...elementState } });
                    saveElementsState(); // Save state after text content changes
                }
            }
        });

        // Helper to get element state for sending via WebSocket
        function getElementState(elementWrapper) {
            const contentElement = elementWrapper.querySelector('img.element-content, audio.element-content, div.text-content.element-content');
            if (!contentElement) return null;

            const state = {
                id: elementWrapper.id,
                left: elementWrapper.style.left,
                top: elementWrapper.style.top,
                width: elementWrapper.style.width,
                height: elementWrapper.style.height,
                rotation: elementWrapper.style.transform,
                zIndex: elementWrapper.style.zIndex,
                opacity: contentElement.style.opacity,
                originalName: elementWrapper.dataset.originalName || ''
            };

            if (contentElement.tagName === 'IMG') {
                state.type = contentElement.tagName.toLowerCase();
                state.src = contentElement.src;
            } else if (contentElement.tagName === 'AUDIO') {
                state.type = contentElement.tagName.toLowerCase();
                state.src = contentElement.src;
                state.volume = contentElement.volume;
                state.currentTime = contentElement.currentTime;
                state.paused = contentElement.paused;
                state.isPlaying = !contentElement.paused;
                state.duration = contentElement.duration;
                state.lastVolume = contentElement.dataset.lastVolume;
            } else if (contentElement.classList.contains('text-content')) {
                state.type = 'text';
                state.textContent = contentElement.textContent;
                state.color = contentElement.style.color;
                state.backgroundColor = contentElement.style.backgroundColor;
                state.fontSize = contentElement.style.fontSize;
                state.isBold = contentElement.classList.contains('font-bold');
                state.isItalic = contentElement.classList.contains('italic');
                state.outlineThickness = contentElement.style.webkitTextStrokeWidth;
                state.outlineColor = contentElement.style.webkitTextStrokeColor;
                state.hasTextBackground = (contentElement.style.backgroundColor !== 'transparent');
                state.hasTextOutline = (parseFloat(contentElement.style.webkitTextStrokeWidth) > 0);
            }
            return state;
        }


        // Handle opacity change
        opacityRange.addEventListener('input', () => {
            if (selectedElementWrapper) {
                const contentElement = selectedElementWrapper.querySelector('.element-content');
                if (contentElement) {
                    contentElement.style.opacity = opacityRange.value;
                    opacityValue.textContent = `${Math.round(opacityRange.value * 100)}%`;
                    sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                    saveElementsState(); // Save state after opacity changes
                }
            }
        });

        // Handle rotation range change (synced with manual rotation)
        rotationRange.addEventListener('input', () => {
            if (selectedElementWrapper) {
                selectedElementWrapper.style.transform = `rotate(${rotationRange.value}deg)`;
                rotationValue.textContent = `${Math.round(rotationRange.value)}°`;
                sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                saveElementsState(); // Save state after rotation changes
            }
        });

        // Handle Duplicate Element
        duplicateElementBtn.addEventListener('click', () => {
            if (allElements.size >= fileLimit) {
                console.warn(`Se ha alcanzado el límite de carga de archivos (${fileLimit} archivos).`);
                return;
            }

            if (selectedElementWrapper) {
                const originalContentElement = selectedElementWrapper.querySelector('.element-content'); // Get the actual content element

                const clonedWrapper = selectedElementWrapper.cloneNode(true); // Deep clone
                const newId = generateUniqueId();
                clonedWrapper.id = newId;
                // Position relative to mainCanvasWrapper now
                clonedWrapper.style.left = `${parseFloat(selectedElementWrapper.style.left) + 20}px`;
                clonedWrapper.style.top = `${parseFloat(selectedElementWrapper.style.top) + 20}px`;
                clonedWrapper.style.zIndex = getNextHighestZIndex(); // Duplicated elements come on top

                clonedWrapper.querySelectorAll('.resize-handle').forEach(handle => handle.style.display = 'none');
                clonedWrapper.querySelector('.rotation-handle').style.display = 'none';

                if (originalContentElement.tagName === 'AUDIO') {
                    // Find the actual audio element within the cloned wrapper (it's the one with .element-content)
                    const clonedAudioElement = clonedWrapper.querySelector('audio.element-content');
                    if (clonedAudioElement) {
                        clonedAudioElement.pause(); // Ensure cloned audio is paused initially
                        clonedAudioElement.currentTime = 0; // Reset audio to start for the clone
                        clonedAudioElement.muted = isMutedGlobally; // Apply global mute state
                        clonedAudioElement.dataset.lastVolume = originalContentElement.dataset.lastVolume || 0.5; // Copy last volume

                        // Re-add event listeners for the *new* audio element instance in the cloned wrapper
                        clonedAudioElement.addEventListener('timeupdate', () => {
                            if (selectedElementWrapper && selectedElementWrapper.id === clonedWrapper.id) {
                                updateTimelineDisplay(clonedAudioElement);
                            }
                        });
                        clonedAudioElement.addEventListener('ended', () => {
                            if (selectedElementWrapper && selectedElementWrapper.id === clonedWrapper.id) {
                                updatePlayPauseButton(true);
                                clonedAudioElement.currentTime = 0;
                                timelineRange.value = 0;
                                currentTimeDisplay.textContent = formatTime(0) + ' / ' + formatTime(clonedAudioElement.duration || 0);
                            }
                        });
                        clonedAudioElement.addEventListener('loadedmetadata', () => {
                            updateTimelineDisplay(clonedAudioElement);
                            // Attempt to play cloned audio if it was originally playing (browser permitting) AND not globally muted
                            if (!originalContentElement.paused && !isMutedGlobally) {
                                clonedAudioElement.play().catch(e => {
                                    console.warn('Autoplay blocked for cloned audio:', e);
                                });
                            }
                        });
                    }
                }
                // If it's a text element, ensure contentEditable is true and handles are removed as per deselectAllElements
                if (originalContentElement.classList.contains('text-content')) {
                    const clonedTextElement = clonedWrapper.querySelector('.text-content.element-content');
                    if (clonedTextElement) {
                        clonedTextElement.contentEditable = true; // Ensure contentEditable is maintained
                        adjustTextElementWrapperSize(clonedWrapper); // Re-adjust size for cloned text
                    }
                }

                mainCanvasWrapper.appendChild(clonedWrapper);
                allElements.set(newId, clonedWrapper);
                selectElement(clonedWrapper);
                updateLayersList();
                updateFileCountDisplay();
                sendWebSocketMessage('elementAdd', { element: getElementState(clonedWrapper) });
                saveElementsState();
            }
        });

        // Handle Delete Element (direct deletion)
        deleteElementBtn.addEventListener('click', () => {
            if (selectedElementWrapper) {
                const contentElement = selectedElementWrapper.querySelector('.element-content');
                if (contentElement && contentElement.tagName === 'AUDIO') {
                    contentElement.pause(); // Pause audio before removing
                    contentElement.src = ''; // Clear source to release resources
                    contentElement.load(); // Load an empty source to fully release
                }
                const deletedId = selectedElementWrapper.id;
                allElements.delete(selectedElementWrapper.id);
                selectedElementWrapper.remove();
                deselectAllElements();
                updateLayersList();
                updateFileCountDisplay(); // Update counter
                sendWebSocketMessage('elementDelete', { elementId: deletedId });
                saveElementsState(); // Save state after deleting an element
            }
        });

        // --- Text Styling Event Listeners ---
        textColorInput.addEventListener('input', () => {
            // Apply to selected element if it's text, otherwise this changes the default for new text
            if (selectedElementWrapper) {
                const contentElement = selectedElementWrapper.querySelector('.element-content');
                if (contentElement && contentElement.classList.contains('text-content')) {
                    contentElement.style.color = textColorInput.value;
                    contentElement.style.webkitTextFillColor = textColorInput.value; // Important for webkit text-stroke to work correctly
                    if (toggleTextOutline.checked) {
                        // Update text-shadow for outline if outline is active
                        contentElement.style.textShadow = generateTextShadowForOutline(outlineThicknessRange.value, textOutlineColorInput.value);
                    }
                    adjustTextElementWrapperSize(selectedElementWrapper); // Re-adjust size after color change (can affect font metrics/rendering slightly)
                    sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                    saveElementsState(); // Save state after text color changes
                }
            }
        });

        textBgColorInput.addEventListener('input', () => {
            // Apply to selected element if it's text, otherwise this changes the default for new text
            if (selectedElementWrapper) {
                const contentElement = selectedElementWrapper.querySelector('.element-content');
                if (contentElement && contentElement.classList.contains('text-content')) {
                    contentElement.style.backgroundColor = textBgColorInput.value;
                    sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                    saveElementsState(); // Save state after text background color changes
                }
            }
        });

        boldTextBtn.addEventListener('click', () => {
            // Apply to selected element if it's text, otherwise this changes the default for new text
            if (selectedElementWrapper) {
                const contentElement = selectedElementWrapper.querySelector('.element-content');
                if (contentElement && contentElement.classList.contains('text-content')) {
                    contentElement.classList.toggle('font-bold');
                    adjustTextElementWrapperSize(selectedElementWrapper); // Re-adjust size as bold can change dimensions
                    sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                    saveElementsState(); // Save state after bold style changes
                }
            }
            boldTextBtn.classList.toggle('active-style'); // Always toggle button active state
        });

        italicTextBtn.addEventListener('click', () => {
            // Apply to selected element if it's text, otherwise this changes the default for new text
            if (selectedElementWrapper) {
                const contentElement = selectedElementWrapper.querySelector('.element-content');
                if (contentElement && contentElement.classList.contains('text-content')) {
                    contentElement.classList.toggle('italic');
                    adjustTextElementWrapperSize(selectedElementWrapper); // Re-adjust size as italic can change dimensions
                    sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                    saveElementsState(); // Save state after italic style changes
                }
            }
            italicTextBtn.classList.toggle('active-style'); // Always toggle button active state
        });

        // Handle background toggle change
        toggleTextBg.addEventListener('change', () => {
            // If a text element is selected, apply change directly
            if (selectedElementWrapper) {
                const textElement = selectedElementWrapper.querySelector('.element-content');
                if (textElement && textElement.classList.contains('text-content')) {
                    if (toggleTextBg.checked) {
                        textElement.style.backgroundColor = textBgColorInput.value;
                        textBgColorInput.disabled = false; // Enable color picker
                        textBgColorLabel.classList.remove('text-gray-600'); // Set label to active color
                        textBgColorLabel.classList.add('text-gray-300');
                    } else {
                        textElement.style.backgroundColor = 'transparent';
                        textBgColorInput.disabled = true; // Disable color picker
                        textBgColorLabel.classList.add('text-gray-600'); // Set label to gray
                        textBgColorLabel.classList.remove('text-gray-300');
                    }
                    sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                    saveElementsState(); // Save state after background toggle changes
                }
            } else {
                // If no text element is selected, this change applies to the default for new text.
                // The color input's disabled state is managed here when toggleTextBg changes.
                 textBgColorInput.disabled = !toggleTextBg.checked;
                 if (toggleTextBg.checked) {
                     textBgColorLabel.classList.remove('text-gray-600');
                     textBgColorLabel.classList.add('text-gray-300');
                 } else {
                     textBgColorLabel.classList.add('text-gray-600');
                     textBgColorLabel.classList.remove('text-gray-300');
                 }
            }
        });

        // Handle outline toggle change
        toggleTextOutline.addEventListener('change', () => {
            if (selectedElementWrapper) {
                const textElement = selectedElementWrapper.querySelector('.element-content');
                if (textElement && textElement.classList.contains('text-content')) {
                    if (toggleTextOutline.checked) {
                        const thickness = outlineThicknessRange.value;
                        const color = textOutlineColorInput.value;
                        textElement.style.webkitTextStrokeWidth = `${thickness}px`;
                        textElement.style.webkitTextStrokeColor = color;
                        textElement.style.textShadow = generateTextShadowForOutline(thickness, color);
                        textOutlineColorInput.disabled = false;
                        outlineThicknessRange.disabled = false;
                        textOutlineColorLabel.classList.remove('text-gray-600');
                        textOutlineColorLabel.classList.add('text-gray-300');
                        outlineThicknessLabel.classList.remove('text-gray-600');
                        outlineThicknessLabel.classList.add('text-gray-300');
                    } else {
                        textElement.style.webkitTextStrokeWidth = '0';
                        textElement.style.webkitTextStrokeColor = 'transparent';
                        textElement.style.textShadow = 'none';
                        textOutlineColorInput.disabled = true;
                        outlineThicknessRange.disabled = true;
                        textOutlineColorLabel.classList.add('text-gray-600');
                        textOutlineColorLabel.classList.remove('text-gray-300');
                        outlineThicknessLabel.classList.add('text-gray-600');
                        outlineThicknessLabel.classList.remove('text-gray-300');
                    }
                    adjustTextElementWrapperSize(selectedElementWrapper); // Re-adjust size after outline toggle
                    sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                    saveElementsState(); // Save state after outline toggle changes
                }
            } else {
                // For new text, just update the disabled state of the color/thickness inputs
                textOutlineColorInput.disabled = !toggleTextOutline.checked;
                outlineThicknessRange.disabled = !toggleTextOutline.checked;
                if (toggleTextOutline.checked) {
                    textOutlineColorLabel.classList.remove('text-gray-600');
                    textOutlineColorLabel.classList.add('text-gray-300');
                    outlineThicknessLabel.classList.remove('text-gray-600');
                    outlineThicknessLabel.classList.add('text-gray-300');
                } else {
                    textOutlineColorLabel.classList.add('text-gray-600');
                    textOutlineColorLabel.classList.remove('text-gray-300');
                    outlineThicknessLabel.classList.add('text-gray-600');
                    outlineThicknessLabel.classList.remove('text-gray-300');
                }
            }
        });

        textOutlineColorInput.addEventListener('input', () => {
            if (selectedElementWrapper) {
                const contentElement = selectedElementWrapper.querySelector('.element-content');
                if (contentElement && contentElement.classList.contains('text-content') && toggleTextOutline.checked) {
                    contentElement.style.webkitTextStrokeColor = textOutlineColorInput.value;
                    contentElement.style.textShadow = generateTextShadowForOutline(outlineThicknessRange.value, textOutlineColorInput.value);
                    adjustTextElementWrapperSize(selectedElementWrapper); // Re-adjust size after color change
                    sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                    saveElementsState(); // Save state after outline color changes
                }
            }
        });

        outlineThicknessRange.addEventListener('input', () => {
            if (selectedElementWrapper) {
                const contentElement = selectedElementWrapper.querySelector('.element-content');
                if (contentElement && contentElement.classList.contains('text-content') && toggleTextOutline.checked) {
                    const thickness = outlineThicknessRange.value;
                    const color = textOutlineColorInput.value;
                    contentElement.style.webkitTextStrokeWidth = `${thickness}px`;
                    contentElement.style.webkitTextStrokeColor = color; // Ensure color is applied with thickness
                    contentElement.style.textShadow = generateTextShadowForOutline(thickness, color);
                    outlineThicknessValue.textContent = `${thickness}px`;
                    adjustTextElementWrapperSize(selectedElementWrapper); // Re-adjust size after thickness change
                    sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                    saveElementsState(); // Save state after outline thickness changes
                }
            } else {
                outlineThicknessValue.textContent = `${outlineThicknessRange.value}px`; // Update display for new text even if disabled
            }
        });

        // Font size control
        fontSizeRange.addEventListener('input', () => {
            if (selectedElementWrapper) {
                const contentElement = selectedElementWrapper.querySelector('.element-content');
                if (contentElement && contentElement.classList.contains('text-content')) {
                    contentElement.style.fontSize = `${fontSizeRange.value}px`;
                    // When font size changes, the text element's wrapper should re-adjust
                    // This ensures the background always fits the new text size.
                    adjustTextElementWrapperSize(selectedElementWrapper);
                    sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                    saveElementsState(); // Save state after font size changes
                }
            }
            fontSizeValue.textContent = `${fontSizeRange.value}px`;
        });


        // --- Reset Buttons Event Listeners ---
        resetOpacityBtn.addEventListener('click', () => {
            if (selectedElementWrapper) {
                const contentElement = selectedElementWrapper.querySelector('.element-content');
                if (contentElement) {
                    contentElement.style.opacity = '1';
                    opacityRange.value = 1;
                    opacityValue.textContent = '100%';
                    sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                    saveElementsState(); // Save state after opacity reset
                }
            }
        });

        resetRotationBtn.addEventListener('click', () => {
            if (selectedElementWrapper) {
                selectedElementWrapper.style.transform = 'rotate(0deg)';
                rotationRange.value = 0;
                rotationValue.textContent = '0°';
                sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                saveElementsState(); // Save state after rotation reset
            }
        });

        // NEW Audio Controls Event Listeners
        playPauseBtn.addEventListener('click', () => {
            if (selectedElementWrapper) {
                const audioElement = selectedElementWrapper.querySelector('audio.element-content'); // Ensure we target the actual audio tag
                if (audioElement) {
                    if (audioElement.paused) {
                        audioElement.play().catch(e => {
                            console.error('Error al reproducir el audio (posible restricción de auto-reproducción del navegador):', e);
                            // Optionally, display a message to the user that autoplay was blocked
                            // For example, you could show a temporary message next to the button.
                        });
                    } else {
                        audioElement.pause();
                    }
                    updatePlayPauseButton(audioElement.paused);
                    sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                    saveElementsState(); // Save state after play/pause changes
                }
            }
        });

        volumeRange.addEventListener('input', () => {
            if (selectedElementWrapper) {
                const audioElement = selectedElementWrapper.querySelector('audio.element-content'); // Ensure we target the actual audio tag
                if (audioElement) {
                    audioElement.volume = parseFloat(volumeRange.value); // Use parseFloat
                    // Store last non-zero volume if not globally muted
                    if (parseFloat(volumeRange.value) > 0 && !isMutedGlobally) {
                        audioElement.dataset.lastVolume = volumeRange.value;
                    }
                    
                    // If volume is 0, mute the audio regardless of global state
                    if (parseFloat(volumeRange.value) === 0) {
                        audioElement.muted = true;
                    } else {
                        // If volume > 0, unmute only if not globally muted
                        audioElement.muted = isMutedGlobally;
                    }
                    volumeValueDisplay.textContent = `${Math.round(volumeRange.value * 100)}%`;
                    sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                    saveElementsState(); // Save state after volume changes
                }
            }
        });

        timelineRange.addEventListener('input', () => {
            if (selectedElementWrapper) {
                const audioElement = selectedElementWrapper.querySelector('audio.element-content'); // Ensure we target the actual audio tag
                if (audioElement) {
                    audioElement.currentTime = timelineRange.value;
                    updateTimelineDisplay(audioElement);
                    sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                    saveElementsState(); // Save state after timeline changes
                }
            }
        });

        // NEW: Global mute/unmute button event listener
        muteToggleBtn.addEventListener('click', () => {
            isMutedGlobally = !isMutedGlobally;
            applyGlobalMuteState();
            // No need to send individual audio updates, the server doesn't manage global mute directly per client.
            // But we do need to save this preference.
        });


        // --- "Bring to Front" Button Event Listener ---
        bringToFrontBtn.addEventListener('click', () => {
            if (selectedElementWrapper) {
                selectedElementWrapper.style.zIndex = getNextHighestZIndex(); // Explicitly bring to front
                updateLayersList(); // Re-render layers to reflect new order
                // Re-select to ensure it stays highlighted and controls are active
                selectElement(selectedElementWrapper);
                sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                // Also send a reorderLayers message to ensure all clients' layer lists are updated correctly
                sendWebSocketMessage('reorderLayers', { elements: Array.from(allElements.values()).map(el => ({ id: el.id, zIndex: el.style.zIndex })) });
                saveElementsState(); // Save state after z-index changes
            }
        });

        // --- Dragging, Resizing, and Rotation Logic ---
        document.addEventListener('mousedown', (e) => {
            const target = e.target;
            const clickedWrapper = target.closest('.element-wrapper');

            // Get mainCanvasWrapper bounding rectangle (this is scaled)
            const wrapperRect = mainCanvasWrapper.getBoundingClientRect();
            
            // Calculate mouse position relative to the unscaled mainCanvasWrapper's top-left
            // This accounts for the wrapper's position on the page and the current zoom level.
            const mouseXOnUnscaledWrapper = (e.clientX - wrapperRect.left) / currentZoom;
            const mouseYOnUnscaledWrapper = (e.clientY - wrapperRect.top) / currentZoom;

            // Check if click is on an element wrapper or its handles
            if (clickedWrapper) {
                e.stopPropagation(); // Stop propagation to prevent deselectAllElements on document click

                // If the click is on a resize handle
                if (target.classList.contains('resize-handle')) {
                    e.preventDefault();
                    isResizing = true;
                    selectedElementWrapper = clickedWrapper;
                    selectElement(selectedElementWrapper); // Select the element

                    // Set activeHandle based on the specific class of the resize handle
                    activeHandle = Array.from(target.classList).find(cls => cls.startsWith('top-') || cls.startsWith('bottom-'));
                    
                    // Store initial mouse position in unscaled mainCanvasWrapper coordinates
                    initialMouseX = mouseXOnUnscaledWrapper;
                    initialMouseY = mouseYOnUnscaledWrapper;

                    // Store initial element properties in unscaled mainCanvasWrapper coordinates
                    initialLeft = selectedElementWrapper.offsetLeft;
                    initialTop = selectedElementWrapper.offsetTop;
                    initialWidth = selectedElementWrapper.offsetWidth; 
                    initialHeight = selectedElementWrapper.offsetHeight; 
                    return;
                }

                // If the click is on a rotation handle
                if (target.classList.contains('rotation-handle')) {
                    e.preventDefault();
                    isRotating = true;
                    selectedElementWrapper = clickedWrapper;
                    selectElement(selectedElementWrapper); // Select the element

                    // Get the *scaled* bounding rectangle of the element for rotation calculation
                    const rect = selectedElementWrapper.getBoundingClientRect(); 
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;

                    initialRotationAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX); // Uses viewport coords
                    initialElementRotation = getRotation(selectedElementWrapper);
                    return;
                }

                // If click is directly on the element wrapper (for dragging)
                e.preventDefault();
                isDragging = true;
                selectElement(clickedWrapper); // Select the element

                // Store initial mouse position in unscaled mainCanvasWrapper coordinates
                initialMouseX = mouseXOnUnscaledWrapper;
                initialMouseY = mouseYOnUnscaledWrapper;

                // Store initial element position in unscaled mainCanvasWrapper coordinates
                initialLeft = selectedElementWrapper.offsetLeft;
                initialTop = selectedElementWrapper.offsetTop;
            } else { // If click is not on an element wrapper
                if (!target.closest('aside') && !target.closest('.zoom-controls') && !target.closest('.modal')) { // If click is not on a wrapper, sidebar, zoom controls, or a modal
                    deselectAllElements();
                }
            }
        });

        document.addEventListener('mousemove', (e) => {
            const wrapperRect = mainCanvasWrapper.getBoundingClientRect(); // Use mainCanvasWrapper
            const currentMouseXOnUnscaledWrapper = (e.clientX - wrapperRect.left) / currentZoom;
            const currentMouseYOnUnscaledWrapper = (e.clientY - wrapperRect.top) / currentZoom;

            if (isDragging && selectedElementWrapper) {
                e.preventDefault();
                const dx = currentMouseXOnUnscaledWrapper - initialMouseX;
                const dy = currentMouseYOnUnscaledWrapper - initialMouseY;

                let newLeft = initialLeft + dx;
                let newTop = initialTop + dy;

                // No clamping here to allow elements to move freely outside the canvas bounds
                selectedElementWrapper.style.left = `${newLeft}px`;
                selectedElementWrapper.style.top = `${newTop}px`;

                // Send update in the next animation frame
                if (!pendingUpdateAnimationFrame) {
                    pendingUpdateAnimationFrame = requestAnimationFrame(() => {
                        sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                        pendingUpdateAnimationFrame = null; // Reset for the next frame
                    });
                }

            } else if (isResizing && selectedElementWrapper) {
                e.preventDefault();
                const dx = currentMouseXOnUnscaledWrapper - initialMouseX;
                const dy = currentMouseYOnUnscaledWrapper - initialMouseY;

                let newWidth = initialWidth;
                let newHeight = initialHeight;
                let newLeft = initialLeft;
                let newTop = initialTop;

                // Use activeHandle to determine resizing direction
                switch (activeHandle) {
                    case 'top-left':
                        newWidth = initialWidth - dx;
                        newHeight = initialHeight - dy;
                        newLeft = initialLeft + dx;
                        newTop = initialTop + dy;
                        break;
                    case 'top-right':
                        newWidth = initialWidth + dx;
                        newHeight = initialHeight - dy;
                        newTop = initialTop + dy;
                        break;
                    case 'bottom-left':
                        newWidth = initialWidth - dx;
                        newHeight = initialHeight + dy;
                        newLeft = initialLeft + dx;
                        break;
                    case 'bottom-right':
                        newWidth = initialWidth + dx;
                        newHeight = initialHeight + dy;
                        break;
                }

                const contentElement = selectedElementWrapper.querySelector('.element-content');
                // Maintain aspect ratio for images
                if (contentElement && (contentElement.tagName === 'IMG')) {
                    const originalAspectRatio = initialWidth / initialHeight;
                    // Recalculate newHeight based on newWidth and aspect ratio to maintain proportions
                    let newHeightFromWidth = newWidth / originalAspectRatio;

                    // Prioritize width changes for right handles, height changes for bottom handles, or calculate based on which change is larger.
                    // For simplicity, let's just adjust height based on width for now, as it's common.
                    newHeight = newHeightFromWidth; 
                    
                    // If height changed significantly, recalculate width based on height
                    if (Math.abs(newHeightFromWidth - (initialHeight + dy)) > Math.abs(newWidth - (initialWidth + dx))) {
                            newWidth = newHeight * originalAspectRatio;
                        }

                    // Adjust position if top or left handles are used and aspect ratio changes
                    if (activeHandle.startsWith('top-') && newHeight !== initialHeight) {
                            newTop = initialTop + (initialHeight - newHeight);
                        }
                    if (activeHandle.endsWith('-left') && newWidth !== initialWidth) {
                            newLeft = initialLeft + (initialWidth - newWidth);
                        }
                } else if (contentElement && contentElement.classList.contains('text-content')) {
                    // For text content, we want the wrapper to *always* be at least the size of the content.
                    const textElement = contentElement; 
                    
                    // Create a temporary, invisible element to measure the text's intrinsic size accurately
                    const tempDiv = document.createElement('div');
                    tempDiv.style.position = 'absolute';
                    tempDiv.style.visibility = 'hidden';
                    tempDiv.style.whiteSpace = 'pre-wrap';
                    tempDiv.style.wordBreak = 'break-word';
                    tempDiv.style.boxSizing = 'border-box';
                    tempDiv.style.fontSize = window.getComputedStyle(textElement).fontSize;
                    tempDiv.style.fontWeight = window.getComputedStyle(textElement).fontWeight;
                    tempDiv.style.fontStyle = window.getComputedStyle(textElement).fontStyle;
                    tempDiv.style.fontFamily = window.getComputedStyle(textElement).fontFamily;
                    tempDiv.style.lineHeight = '1'; // IMPORTANT: Match new CSS for precise measurement
                    tempDiv.style.textAlign = 'center';

                    // NEW: Add flex properties to tempDiv for accurate measurement
                    tempDiv.style.display = 'flex';
                    tempDiv.style.alignItems = 'center';
                    tempDiv.style.justifyContent = 'center';
                    
                    // Retrieve outline properties directly from the element if they exist
                    const outlineThickness = parseFloat(textElement.style.webkitTextStrokeWidth) || 0;
                    const outlineColor = textElement.style.webkitTextStrokeColor || '#000000';

                    if (outlineThickness > 0) {
                        tempDiv.style.webkitTextStrokeWidth = `${outlineThickness}px`;
                        tempDiv.style.webkitTextStrokeColor = outlineColor;
                        tempDiv.style.textShadow = generateTextShadowForOutline(outlineThickness, outlineColor);
                    } else {
                        tempDiv.style.webkitTextStrokeWidth = '0';
                        tempDiv.style.webkitTextStrokeColor = 'transparent';
                        tempDiv.style.textShadow = 'none';
                    }
                    
                    tempDiv.textContent = textElement.textContent;
                    document.body.appendChild(tempDiv);

                    const rawTextRect = tempDiv.getBoundingClientRect();
                    const minContentWidth = rawTextRect.width;
                    const minContentHeight = rawTextRect.height;
                    document.body.removeChild(tempDiv);

                    const wrapperPaddingHorizontal = 25; // Same as in adjustTextElementWrapperSize
                    const wrapperPaddingVertical = 10;   // Same as in adjustTextElementWrapperSize

                    // Clamp newWidth and newHeight to ensure they are at least the minimum content size + padding
                    const clampedWidth = Math.max(newWidth, minContentWidth + (wrapperPaddingHorizontal * 2));
                    const clampedHeight = Math.max(newHeight, minContentHeight + (wrapperPaddingVertical * 2));

                    // Adjust position if clamping changed dimensions and it's a top/left handle
                    const widthDiff = clampedWidth - newWidth;
                    const heightDiff = clampedHeight - newHeight;

                    if (activeHandle.startsWith('top-')) {
                        newTop -= heightDiff;
                    } 

                    if (activeHandle.endsWith('-left')) {
                        newLeft -= widthDiff;
                    } 

                    newWidth = clampedWidth;
                    newHeight = clampedHeight;
                }

                // Ensure minimum size (unscaled) for all elements
                newWidth = Math.max(20, newWidth);
                newHeight = Math.max(20, newHeight);

                selectedElementWrapper.style.width = `${newWidth}px`;
                selectedElementWrapper.style.height = `${newHeight}px`;
                selectedElementWrapper.style.left = `${newLeft}px`;
                selectedElementWrapper.style.top = `${newTop}px`;

                // Update initial mouse position for the next move
                initialMouseX = currentMouseXOnUnscaledWrapper;
                initialMouseY = currentMouseYOnUnscaledWrapper;
                initialWidth = newWidth;
                initialHeight = newHeight;
                initialLeft = newLeft;
                initialTop = newTop;

                // Send update in the next animation frame
                if (!pendingUpdateAnimationFrame) {
                    pendingUpdateAnimationFrame = requestAnimationFrame(() => {
                        sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                        pendingUpdateAnimationFrame = null;
                    });
                }
            } else if (isRotating && selectedElementWrapper) {
                e.preventDefault();
                // Get the *scaled* bounding rectangle of the element for rotation calculation
                const rect = selectedElementWrapper.getBoundingClientRect(); 
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                const currentAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                const angleDiff = (currentAngle - initialRotationAngle) * 180 / Math.PI;
                let newRotation = initialElementRotation + angleDiff;

                newRotation = (newRotation % 360 + 360) % 360;

                selectedElementWrapper.style.transform = `rotate(${newRotation}deg)`;
                rotationRange.value = newRotation;
                rotationValue.textContent = `${Math.round(newRotation)}°`;

                // Send update in the next animation frame
                if (!pendingUpdateAnimationFrame) {
                    pendingUpdateAnimationFrame = requestAnimationFrame(() => {
                        sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                        pendingUpdateAnimationFrame = null;
                    });
                }
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDragging || isResizing || isRotating) {
                // Ensure the final state is sent when interaction ends
                if (pendingUpdateAnimationFrame) {
                    cancelAnimationFrame(pendingUpdateAnimationFrame); // Cancel any pending frame
                    pendingUpdateAnimationFrame = null; // Reset
                }
                if (selectedElementWrapper) {
                    sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                }
                saveElementsState(); // Save state after drag, resize or rotate ends
            }
            isDragging = false;
            isResizing = false;
            isRotating = false;
            activeHandle = '';
        });

        // --- Touch Events (modified to include rotation) ---
        document.addEventListener('touchstart', (e) => {
            const target = e.target;
            const clickedWrapper = target.closest('.element-wrapper');

            // Get mainCanvasWrapper bounding rectangle (this is scaled)
            const wrapperRect = mainCanvasWrapper.getBoundingClientRect();
            // Convert touch coordinates to relative to the unscaled mainCanvasWrapper's top-left
            const touchXOnUnscaledWrapper = (e.touches[0].clientX - wrapperRect.left) / currentZoom;
            const touchYOnUnscaledWrapper = (e.touches[0].clientY - wrapperRect.top) / currentZoom;

            if (e.touches.length === 1) {
                if (clickedWrapper) {
                     // If the touch is on a resize handle
                    if (target.classList.contains('resize-handle')) {
                        e.preventDefault();
                        isResizing = true;
                        selectedElementWrapper = clickedWrapper;
                        selectElement(selectedElementWrapper); // Select the element

                        // Set activeHandle based on the specific class of the resize handle
                        activeHandle = Array.from(target.classList).find(cls => cls.startsWith('top-') || cls.startsWith('bottom-'));
                        
                        // Store initial touch position in unscaled mainCanvasWrapper coordinates
                        initialMouseX = touchXOnUnscaledWrapper;
                        initialMouseY = touchYOnUnscaledWrapper;

                        // Store initial element properties in unscaled mainCanvasWrapper coordinates
                        initialLeft = selectedElementWrapper.offsetLeft;
                        initialTop = selectedElementWrapper.offsetTop;
                        initialWidth = selectedElementWrapper.offsetWidth; 
                        initialHeight = selectedElementWrapper.offsetHeight; 
                        return;
                    }

                    // If the touch is on a rotation handle
                    if (target.classList.contains('rotation-handle')) {
                        e.preventDefault();
                        isRotating = true;
                        selectedElementWrapper = clickedWrapper;
                        selectElement(selectedElementWrapper); // Select the element

                        const rect = selectedElementWrapper.getBoundingClientRect(); // This is scaled in viewport coords
                        const centerX = rect.left + rect.width / 2;
                        const centerY = rect.top + rect.height / 2;

                        initialRotationAngle = Math.atan2(e.touches[0].clientY - centerY, e.touches[0].clientX - centerX); // Uses viewport coords
                        initialElementRotation = getRotation(selectedElementWrapper);
                        return;
                    }

                    // If touch is directly on the element wrapper (for dragging)
                    e.preventDefault();
                    isDragging = true;
                    selectElement(clickedWrapper); // Select the element

                    // Store initial touch position in unscaled mainCanvasWrapper coordinates
                    initialMouseX = touchXOnUnscaledWrapper;
                    initialMouseY = touchYOnUnscaledWrapper;

                    // Store initial element position in unscaled mainCanvasWrapper coordinates
                    initialLeft = clickedWrapper.offsetLeft;
                    initialTop = clickedWrapper.offsetTop;
                } else { // If click is not on an element wrapper
                    if (!target.closest('aside') && !target.closest('.zoom-controls') && !target.closest('.modal')) { // If click is not on a wrapper, sidebar, zoom controls, or a modal
                        deselectAllElements();
                    }
                }
            }
        });

        document.addEventListener('touchmove', (e) => {
            const wrapperRect = mainCanvasWrapper.getBoundingClientRect(); // Use mainCanvasWrapper
            const currentTouchXOnUnscaledWrapper = (e.touches[0].clientX - wrapperRect.left) / currentZoom;
            const currentTouchYOnUnscaledWrapper = (e.touches[0].clientY - wrapperRect.top) / currentZoom;

            if (e.touches.length === 1) {
                if (isDragging && selectedElementWrapper) {
                    e.preventDefault();
                    const dx = currentTouchXOnUnscaledWrapper - initialMouseX;
                    const dy = currentTouchYOnUnscaledWrapper - initialMouseY;

                    let newLeft = initialLeft + dx;
                    let newTop = initialTop + dy;

                    selectedElementWrapper.style.left = `${newLeft}px`;
                    selectedElementWrapper.style.top = `${newTop}px`;

                    // Send update in the next animation frame
                    if (!pendingUpdateAnimationFrame) {
                        pendingUpdateAnimationFrame = requestAnimationFrame(() => {
                            sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                            pendingUpdateAnimationFrame = null;
                        });
                    }

                } else if (isResizing && selectedElementWrapper) {
                    e.preventDefault();
                    const dx = currentTouchXOnUnscaledWrapper - initialMouseX;
                    const dy = currentTouchYOnUnscaledWrapper - initialMouseY;

                    let newWidth = initialWidth;
                    let newHeight = initialHeight;
                    let newLeft = initialLeft;
                    let newTop = initialTop;

                    // Use activeHandle to determine resizing direction
                    switch (activeHandle) {
                        case 'top-left':
                            newWidth = initialWidth - dx;
                            newHeight = initialHeight - dy;
                            newLeft = initialLeft + dx;
                            newTop = initialTop + dy;
                            break;
                        case 'top-right':
                            newWidth = initialWidth + dx;
                            newHeight = initialHeight - dy;
                            newTop = initialTop + dy;
                            break;
                        case 'bottom-left':
                            newWidth = initialWidth - dx;
                            newHeight = initialHeight + dy;
                            newLeft = initialLeft + dx;
                            break;
                        case 'bottom-right':
                            newWidth = initialWidth + dx;
                            newHeight = initialHeight + dy;
                            break;
                    }

                    const contentElement = selectedElementWrapper.querySelector('.element-content');
                    // Maintain aspect ratio for images
                    if (contentElement && (contentElement.tagName === 'IMG')) {
                        const originalAspectRatio = initialWidth / initialHeight;
                        // Recalculate newHeight based on newWidth and aspect ratio to maintain proportions
                        let newHeightFromWidth = newWidth / originalAspectRatio;

                        // Prioritize width changes for right handles, height changes for bottom handles, or calculate based on which change is larger.
                        // For simplicity, let's just adjust height based on width for now, as it's common.
                        newHeight = newHeightFromWidth; 
                        
                        // If height changed significantly, recalculate width based on height
                        if (Math.abs(newHeightFromWidth - (initialHeight + dy)) > Math.abs(newWidth - (initialWidth + dx))) {
                                newWidth = newHeight * originalAspectRatio;
                            }

                        // Adjust position if top or left handles are used and aspect ratio changes
                        if (activeHandle.startsWith('top-') && newHeight !== initialHeight) {
                                newTop = initialTop + (initialHeight - newHeight);
                            }
                        if (activeHandle.endsWith('-left') && newWidth !== initialWidth) {
                                newLeft = initialLeft + (initialWidth - newWidth);
                            }
                    } else if (contentElement && contentElement.classList.contains('text-content')) {
                        // For text content, we want the wrapper to *always* be at least the size of the content.
                        const textElement = contentElement; 
                        
                        // Create a temporary, invisible element to measure the text's intrinsic size accurately
                        const tempDiv = document.createElement('div');
                        tempDiv.style.position = 'absolute';
                        tempDiv.style.visibility = 'hidden';
                        tempDiv.style.whiteSpace = 'pre-wrap';
                        tempDiv.style.wordBreak = 'break-word';
                        tempDiv.style.boxSizing = 'border-box';
                        tempDiv.style.fontSize = window.getComputedStyle(textElement).fontSize;
                        tempDiv.style.fontWeight = window.getComputedStyle(textElement).fontWeight;
                        tempDiv.style.fontStyle = window.getComputedStyle(textElement).fontStyle;
                        tempDiv.style.fontFamily = window.getComputedStyle(textElement).fontFamily;
                        tempDiv.style.lineHeight = '1'; // IMPORTANT: Match new CSS for precise measurement
                        tempDiv.style.textAlign = 'center';

                        // NEW: Add flex properties to tempDiv for accurate measurement
                        tempDiv.style.display = 'flex';
                        tempDiv.style.alignItems = 'center';
                        tempDiv.style.justifyContent = 'center';
                        
                        // Retrieve outline properties directly from the element if they exist
                        const outlineThickness = parseFloat(textElement.style.webkitTextStrokeWidth) || 0;
                        const outlineColor = textElement.style.webkitTextStrokeColor || '#000000';

                        if (outlineThickness > 0) {
                            tempDiv.style.webkitTextStrokeWidth = `${outlineThickness}px`;
                            tempDiv.style.webkitTextStrokeColor = outlineColor;
                            tempDiv.style.textShadow = generateTextShadowForOutline(outlineThickness, outlineColor);
                        } else {
                            tempDiv.style.webkitTextStrokeWidth = '0';
                            tempDiv.style.webkitTextStrokeColor = 'transparent';
                            tempDiv.style.textShadow = 'none';
                        }
                        
                        tempDiv.textContent = textElement.textContent;
                        document.body.appendChild(tempDiv);

                        const rawTextRect = tempDiv.getBoundingClientRect();
                        const minContentWidth = rawTextRect.width;
                        const minContentHeight = rawTextRect.height;
                        document.body.removeChild(tempDiv);

                        const wrapperPaddingHorizontal = 25; // Same as in adjustTextElementWrapperSize
                        const wrapperPaddingVertical = 10;   // Same as in adjustTextElementWrapperSize

                        // Clamp newWidth and newHeight to ensure they are at least the minimum content size + padding
                        const clampedWidth = Math.max(newWidth, minContentWidth + (wrapperPaddingHorizontal * 2));
                        const clampedHeight = Math.max(newHeight, minContentHeight + (wrapperPaddingVertical * 2));

                        // Adjust position if clamping changed dimensions and it's a top/left handle
                        const widthDiff = clampedWidth - newWidth;
                        const heightDiff = clampedHeight - newHeight;

                        if (activeHandle.startsWith('top-')) {
                            newTop -= heightDiff;
                        } 

                        if (activeHandle.endsWith('-left')) {
                            newLeft -= widthDiff;
                        } 

                        newWidth = clampedWidth;
                        newHeight = clampedHeight;
                    }

                    // Ensure minimum size (unscaled) for all elements
                    newWidth = Math.max(20, newWidth);
                    newHeight = Math.max(20, newHeight);

                    selectedElementWrapper.style.width = `${newWidth}px`;
                    selectedElementWrapper.style.height = `${newHeight}px`;
                    selectedElementWrapper.style.left = `${newLeft}px`;
                    selectedElementWrapper.style.top = `${newTop}px`;

                    // Update initial mouse position for the next move
                    initialMouseX = currentTouchXOnUnscaledWrapper;
                    initialMouseY = currentTouchYOnUnscaledWrapper;
                    initialWidth = newWidth;
                    initialHeight = newHeight;
                    initialLeft = newLeft;
                    initialTop = newTop;

                    // Send update in the next animation frame
                    if (!pendingUpdateAnimationFrame) {
                        pendingUpdateAnimationFrame = requestAnimationFrame(() => {
                            sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                            pendingUpdateAnimationFrame = null;
                        });
                    }
                } else if (isRotating && selectedElementWrapper) {
                    e.preventDefault();
                    const rect = selectedElementWrapper.getBoundingClientRect(); // This is scaled in viewport coords
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;

                    const currentAngle = Math.atan2(e.touches[0].clientY - centerY, e.touches[0].clientX - centerX);
                    const angleDiff = (currentAngle - initialRotationAngle) * 180 / Math.PI;
                    let newRotation = initialElementRotation + angleDiff;

                    newRotation = (newRotation % 360 + 360) % 360;

                    selectedElementWrapper.style.transform = `rotate(${newRotation}deg)`;
                    rotationRange.value = newRotation;
                    rotationValue.textContent = `${Math.round(newRotation)}°`;

                    // Send update in the next animation frame
                    if (!pendingUpdateAnimationFrame) {
                        pendingUpdateAnimationFrame = requestAnimationFrame(() => {
                            sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                            pendingUpdateAnimationFrame = null;
                        });
                    }
                }
            }
        });

        document.addEventListener('touchend', () => {
            if (isDragging || isResizing || isRotating) {
                // Ensure the final state is sent when interaction ends
                if (pendingUpdateAnimationFrame) {
                    cancelAnimationFrame(pendingUpdateAnimationFrame); // Cancel any pending frame
                    pendingUpdateAnimationFrame = null; // Reset
                }
                if (selectedElementWrapper) {
                    sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                }
                saveElementsState(); // Save state after drag, resize or rotate ends
            }
            isDragging = false;
            isResizing = false;
            isRotating = false;
            activeHandle = '';
        });

        // --- Tab Logic ---
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', () => {
                const tabId = button.dataset.tab;

                document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

                button.classList.add('active');
                document.getElementById(`tab-content-${tabId}`).classList.add('active');
            });
        });

        // --- Layer Reordering (Drag and Drop) ---
        let draggedLayer = null;

        layersList.addEventListener('dragstart', (e) => {
            const target = e.target.closest('.layer-item');
            if (target) {
                draggedLayer = target;
                e.dataTransfer.effectAllowed = 'move';
                // Use a small timeout to avoid flickering when element is picked up
                setTimeout(() => {
                    target.style.opacity = '0.5';
                }, 0);
            }
        });

        layersList.addEventListener('dragover', (e) => {
            e.preventDefault(); // Necessary to allow drop
            const target = e.target.closest('.layer-item');
            if (target && target !== draggedLayer) {
                const bounding = target.getBoundingClientRect();
                const offset = bounding.y + (bounding.height / 2);
                if (e.clientY < offset) {
                    layersList.insertBefore(draggedLayer, target);
                } else {
                    layersList.insertBefore(draggedLayer, target.nextSibling);
                }
            }
        });

        layersList.addEventListener('dragend', () => {
            if (draggedLayer) {
                draggedLayer.style.opacity = '1';
                draggedLayer = null;

                // Get the current highest z-index from elements on the mainCanvasWrapper
                let maxZ = getNextHighestZIndex() - 1; 
                // Ensure a reasonable base for reordering if mainCanvasWrapper is empty or has low Z-indices
                if (maxZ < 100) { 
                    maxZ = 100;
                }
                
                // Iterate through the layersList.children in their *new* DOM order (top to bottom of list)
                // Assign decreasing Z-indices starting from maxZ
                const layersInNewOrder = Array.from(layersList.children);
                
                const updatedElementsForReorder = [];
                layersInNewOrder.forEach((layerItem, index) => {
                    if (layerItem.dataset.id) {
                        const elementWrapper = allElements.get(layerItem.dataset.id);
                        if (elementWrapper) {
                            const newZIndex = maxZ - index;
                            elementWrapper.style.zIndex = newZIndex;
                            updatedElementsForReorder.push({ id: elementWrapper.id, zIndex: newZIndex });
                        }
                    }
                });

                // Update the layers list display and re-select the element (if it was selected)
                updateLayersList();
                sendWebSocketMessage('reorderLayers', { elements: updatedElementsForReorder });
                saveElementsState(); // Save state after layer reordering
            }
        });

        // Zoom event listener
        zoomRange.addEventListener('input', () => {
            currentZoom = parseFloat(zoomRange.value);
            applyZoom();
            // After zooming, re-select if an element is selected to update handle positions
            // This is already handled by the general selectElement when an element is active.
        });

        // --- Drag and Drop File Upload Event Listeners ---
        dropArea.addEventListener('dragover', (e) => {
            e.preventDefault(); // Prevent default to allow drop
            dropArea.classList.add('highlight'); // Add highlight style
            e.dataTransfer.dropEffect = 'copy'; // Visual feedback for copying
        });

        dropArea.addEventListener('dragleave', () => {
            dropArea.classList.remove('highlight'); // Remove highlight style
        });

        dropArea.addEventListener('drop', (e) => {
            e.preventDefault(); // Prevent default file open behavior
            dropArea.classList.remove('highlight'); // Remove highlight style

            if (e.dataTransfer.files.length > 0) {
                handleFile(e.dataTransfer.files[0]);
            }
        });


        document.addEventListener('DOMContentLoaded', () => {
            // Conectar a WebSocket al cargar la página
            connectWebSocket();

            // Load elements from localStorage first (as a local cache/initial state before WebSocket sync)
            loadElementsState();
            
            // applyZoom will handle the transform and centering of mainCanvasWrapper
            mainCanvasWrapper.style.transformOrigin = 'center center'; // Set initial transform origin

            // Initial setup
            deselectAllElements();
            updateLayersList();
            updateFileCountDisplay(); // Initial call to display the file count
            applyZoom(); // Apply initial zoom and center the view
            applyGlobalMuteState(); // Apply initial global mute state after loading
        });
    </script>
</body>
</html>
