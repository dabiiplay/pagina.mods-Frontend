<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Página Mods</title>
    <link rel="icon" href="./cat.png" type="image/png">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: "Inter", sans-serif;
            overflow: hidden;
            background-color: #1a202c;
        }
        .element-wrapper {
            position: absolute;
            cursor: grab;
            user-select: none;
            box-sizing: border-box;
            transition: box-shadow 0.1s ease-in-out, opacity 0.5s ease-in-out;
            will-change: transform, left, top, opacity;
        }
        .element-wrapper.selected {
            box-shadow: 0 0 0 2px #8B5CF6;
            cursor: grabbing;
        }
        .text-element-wrapper {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .element-content {
            display: block;
            object-fit: contain;
            width: 100%;
            height: 100%;
        }
        .audio-visual-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            width: 100%;
            pointer-events: none;
        }
        .text-content {
            white-space: pre-wrap;
            word-break: break-word;
            text-align: center;
            box-sizing: border-box;
            line-height: 1;
            padding: 0px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #8B5CF6;
            border: 1px solid #ffffff;
            cursor: grab;
            z-index: 1000;
        }
        .resize-handle.top-left { top: -5px; left: -5px; cursor: nwse-resize; }
        .resize-handle.top-right { top: -5px; right: -5px; cursor: nesw-resize; }
        .resize-handle.bottom-left { bottom: -5px; left: -5px; cursor: nesw-resize; }
        .resize-handle.bottom-right { bottom: -5px; right: -5px; cursor: nwse-resize; }
        .rotation-handle {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 20px;
            background-color: #8B5CF6;
            border-radius: 50%;
            border: 1px solid #ffffff;
            cursor: grab;
            z-index: 1000;
            display: none;
        }
        .sidebar-scroll {
            overflow-y: auto;
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        .sidebar-scroll::-webkit-scrollbar {
            display: none;
        }
        .tab-button {
            padding: 0.35rem 1rem;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            font-weight: 600;
            color: #A0AEC0;
            transition: all 0.2s ease-in-out;
            padding-left: 1rem;
            padding-right: 1rem;
        }
        .tab-button.active {
            border-bottom-color: transparent;
            background-color: #4A5568;
            color: #FFFFFF;
        }
        .tab-content {
            display: none;
            padding-top: 0.5rem;
        }
        .tab-content.active {
            display: block;
        }
        .layer-item {
            display: flex;
            align-items: center;
            padding: 0.5rem 0.75rem;
            background-color: #2D3748;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, opacity 0.2s ease-in-out;
            color: #E2E8F0;
        }
        .layer-item:hover {
            background-color: #4A5568;
        }
        .layer-item.selected {
            background-color: #8B5CF6;
            color: #FFFFFF;
        }
        .audio-list-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 0.75rem;
            background-color: #2D3748;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            color: #E2E8F0;
            border-radius: 0.375rem;
        }
        .audio-list-item:hover {
            background-color: #4A5568;
        }
        .audio-list-item.selected {
            background-color: #8B5CF6;
            color: #FFFFFF;
        }
        .audio-list-item button svg {
            pointer-events: none;
        }
        button.active-style {
            background-color: #8B5CF6;
            border: 1px solid #7C3AED;
        }
        .reset-button {
            background: none;
            border: none;
            cursor: pointer;
            color: #A0AEC0;
            padding: 0.25rem;
            line-height: 1;
        }
        .reset-button:hover {
            color: #E2E8F0;
        }
        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-color: transparent;
            border: none;
            cursor: pointer;
            width: 100%;
            height: 2.5rem;
        }
        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch {
            border: none;
        }
        input[type="color"]::-moz-color-remap-panel {
            border: none;
        }
        input[type="color"]::-moz-color-swatch {
        }
        .custom-file-input {
            position: relative;
            overflow: hidden;
            display: inline-block;
            cursor: pointer;
        }
        .custom-file-input input[type="file"] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }
        input[type="range"].w-full {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
            width: 100%;
            height: 8px;
        }
        input[type="range"].w-full::-webkit-slider-runnable-track {
            background: #4A5568;
            border-radius: 4px;
            height: 4px;
        }
        input[type="range"].w-full::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            background-color: #8B5CF6;
            border: 1px solid #FFFFFF;
            border-radius: 50%;
            height: 16px;
            width: 16px;
            margin-top: -6px;
        }
        input[type="range"].w-full::-moz-range-track {
            background: #4A5568;
            border-radius: 4px;
            height: 4px;
        }
        input[type="range"].w-full::-moz-range-thumb {
            background-color: #8B5CF6;
            border: 1px solid #FFFFFF;
            border-radius: 50%;
            height: 16px;
            width: 16px;
        }
        main#editorCanvas {
            position: relative;
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 1rem;
            overflow: hidden;
        }
        #mainCanvasWrapper {
            display: flex;
            position: relative;
            width: 1496px;
            height: 720px;
            transform-origin: center center;
            flex-shrink: 0;
        }
        #leftSidebar {
            width: 200px;
            height: 720px;
            background-color: rgba(16, 185, 129, 0.5);
            border: 2px dashed #4ade80;
            margin-right: 1rem;
            flex-shrink: 0;
        }
        #innerCanvas {
            width: 1280px;
            height: 720px;
            background-color: transparent;
            border: 2px dashed white;
            flex-shrink: 0;
        }
        #dropArea {
            border: 2px dashed #4A5568;
            background-color: #2D3748;
            text-align: center;
            padding: 1rem;
            margin-top: 1rem;
            color: #A0AEC0;
            font-size: 0.875rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
        }
        #dropArea.highlight {
            background-color: #4A5568;
            border-color: #8B5CF6;
        }
        #newZoomRange::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            background-color: #8B5CF6;
            border: 1px solid #FFFFFF;
            border-radius: 50%;
            height: 16px;
            width: 16px;
            margin-top: -5px;
        }
        #newZoomRange::-moz-range-thumb {
            background-color: #8B5CF6;
            border: 1px solid #FFFFFF;
            border-radius: 50%;
            height: 16px;
            width: 16px;
            margin-top: -5px;
        }
        #wsStatus {
            font-size: 0.75rem;
            font-weight: 500;
            margin-top: 0.5rem;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            text-align: center;
        }
        #wsStatus.connected {
            background-color: #10B981;
            color: #064E40;
        }
        #wsStatus.disconnected {
            background-color: #EF4444;
            color: #7F1D1D;
        }
        #wsStatus.connecting {
            background-color: #FBBF24;
            color: #78350F;
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.3s ease-in-out;
            opacity: 0;
            pointer-events: none;
        }
        .modal-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }
        .modal-dialog {
            background-color: #2D3748;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.3);
            max-width: 90%;
            width: 400px;
            text-align: center;
            color: #E2E8F0;
            transform: translateY(-20px);
            transition: transform 0.3s ease-in-out;
        }
        .modal-overlay.active .modal-dialog {
            transform: translateY(0);
        }
        .modal-title {
            font-size: 1.25rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: #8B5CF6;
        }
        .modal-message {
            font-size: 1rem;
            margin-bottom: 1.5rem;
            line-height: 1.5;
        }
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
        }
        .modal-button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
        }
        .modal-button:hover {
            transform: translateY(-2px);
        }
        .modal-button.mute {
            background-color: #EF4444;
            color: #FFFFFF;
            border: 1px solid #DC2626;
        }
        .modal-button.mute:hover {
            background-color: #DC2626;
        }
        .modal-button.sound {
            background-color: #10B981;
            color: #FFFFFF;
            border: 1px solid #059669;
        }
        .modal-button.sound:hover {
            background-color: #059669;
        }
        .modal-button.ok {
            background-color: #8B5CF6;
            color: #FFFFFF;
            border: 1px solid #7C3AED;
        }
        .modal-button.ok:hover {
            background-color: #7C3AED;
        }
    </style>
</head>
<body class="h-screen flex text-gray-800">
    <div id="mutePreferenceModal" class="modal-overlay">
        <div class="modal-dialog">
            <h3 class="modal-title">¡Atención!</h3>
            <p class="modal-message">
                Se recomienda silenciar la página para evitar interrupciones.
            </p>
            <div class="modal-buttons">
                <button id="modalMuteBtn" class="modal-button mute">Silenciar</button>
                <button id="modalSoundBtn" class="modal-button sound">Con Sonido</button>
            </div>
        </div>
    </div>
    <aside class="w-80 bg-gray-900 shadow-lg flex flex-col sidebar-scroll text-gray-200 pt-4 z-20">
        <div class="border-b pb-2 border-gray-700 px-4">
            <label for="imageUpload" class="block text-sm font-medium text-gray-300 mb-2 text-center">Subir Imagen/GIF/MP3</label>
            <div class="custom-file-input w-full bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2 px-4 cursor-pointer transition-colors duration-200 text-center">
                <span id="selectFileButtonText">Seleccionar archivo</span>
                <input type="file" id="imageUpload" accept="image/*, audio/*" class="block w-full text-sm text-gray-400">
            </div>
            <span id="fileCountDisplay" class="block text-xs text-gray-400 mt-2 text-center">0/50</span>
            <div id="dropArea">Arrastra y suelta archivos aquí</div>
            <div id="wsStatus" class="disconnected">Desconectado</div>
        </div>
        <div class="flex border-b border-gray-700">
            <button class="tab-button active flex-1 text-center" data-tab="properties">Ajustes</button>
            <button class="tab-button flex-1 text-center" data-tab="text">Texto</button>
            <button class="tab-button flex-1 text-center" data-tab="audio">Audio</button>
            <button class="tab-button flex-1 text-center" data-tab="layers">Capas</button>
        </div>
        <div id="tab-content-properties" class="tab-content active flex-grow px-4">
            <h2 class="text-lg font-semibold mb-4 text-purple-400">Controles de Elemento</h2>
            <div class="mb-4">
                <label for="opacityRange" class="block text-sm font-medium text-gray-300 mb-2">Opacidad</label>
                <div class="flex items-center space-x-2">
                    <input type="range" id="opacityRange" min="0" max="1" step="0.01" value="1" disabled class="w-full h-2 bg-gray-700 appearance-none cursor-pointer range-shadow">
                    <span id="opacityValue" class="text-xs text-gray-400 w-10 text-right">100%</span>
                    <button id="resetOpacityBtn" class="reset-button" title="Reiniciar Opacidad" disabled>
                        <svg xmlns="http://www.w3.org/2000/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-4 h-4">
                            <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="mb-4">
                <label for="rotationRange" class="block text-sm font-medium text-gray-300 mb-2">Rotación</label>
                <div class="flex items-center space-x-2">
                    <input type="range" id="rotationRange" min="0" max="360" step="1" value="0" disabled class="w-full h-2 bg-gray-700 appearance-none cursor-pointer range-shadow">
                    <span id="rotationValue" class="text-xs text-gray-400 w-10 text-right">0°</span>
                    <button id="resetRotationBtn" class="reset-button" title="Reiniciar Rotación" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-4 h-4">
                            <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="mb-6">
                <label for="sizeRange" class="block text-sm font-medium text-gray-300 mb-2">Tamaño</label>
                <div class="flex items-center space-x-2">
                    <input type="range" id="sizeRange" min="0.25" max="4.0" step="0.05" value="1.0" disabled class="w-full h-2 bg-gray-700 appearance-none cursor-pointer range-shadow">
                    <span id="sizeValue" class="text-xs text-gray-400 w-10 text-right">100%</span>
                    <button id="resetSizeBtn" class="reset-button" title="Reiniciar Tamaño" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-4 h-4">
                            <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
                        </svg>
                    </button>
                </div>
            </div>
            <button id="duplicateElementBtn" disabled class="w-full bg-purple-700 hover:bg-purple-800 text-white font-bold py-2 px-4 shadow-md transition-all duration-200 mb-3 disabled:opacity-50 disabled:cursor-not-allowed">
                Duplicar elemento
            </button>
            <button id="bringToFrontBtn" disabled class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 shadow-md transition-all duration-200 mb-3 disabled:opacity-50 disabled:cursor-not-allowed">
                Traer al frente
            </button>
            <button id="deleteElementBtn" disabled class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 shadow-md transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed mb-4">
                Eliminar elemento
            </button>
        </div>
        <div id="tab-content-text" class="tab-content flex-grow px-4">
            <label for="textInput" class="block text-sm font-medium text-gray-300 mb-2">Contenido del Texto</label>
            <textarea id="textInput" class="w-full p-2 border border-gray-600 bg-gray-700 text-gray-100 focus:outline-none focus:ring-purple-400" rows="3" placeholder="Escribe aquí el texto"></textarea>
            <button id="addTextBtn" class="w-full bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 shadow-md transition-all duration-200 mb-4">
                Añadir Texto al Lienzo
            </button>
            <h3 class="text-md font-semibold mb-2 text-purple-400 mt-6">Ajustes de Estilo de Texto</h3>
            <div class="flex space-x-2 mb-4">
                <button id="boldTextBtn" class="flex-1 bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 shadow-md transition-all duration-200">
                    Negrita
                </button>
                <button id="italicTextBtn" class="flex-1 bg-gray-700 hover:bg-gray-600 text-white italic py-2 px-4 shadow-md transition-all duration-200">
                    Cursiva
                </button>
            </div>
            <div class="mb-4">
                <label for="fontSizeRange" class="block text-sm font-medium text-gray-300 mb-2">Tamaño del Texto</label>
                <div class="flex items-center space-x-2">
                    <input type="range" id="fontSizeRange" min="10" max="100" step="1" value="24" class="w-full h-2 bg-gray-700 appearance-none cursor-pointer range-shadow">
                    <span id="fontSizeValue" class="text-xs text-gray-400 w-10 text-right">24px</span>
                </div>
            </div>
            <div class="mb-4">
                <label for="textColor" class="block text-sm font-medium text-gray-300 mb-2">Color del Texto</label>
                <input type="color" id="textColor" value="#FFFFFF" class="w-full h-8 border border-gray-600 bg-gray-700 p-1 cursor-pointer">
            </div>
            <div class="mb-4">
                <div class="flex items-center justify-between space-x-2">
                    <label for="toggleTextBg" class="text-sm font-medium text-gray-300 cursor-pointer">Fondo del Texto</label>
                    <div class="flex items-center space-x-2">
                        <input type="checkbox" id="toggleTextBg" class="h-4 w-4 text-purple-600 bg-gray-700 border-gray-600 focus:ring-purple-500">
                        <label for="toggleTextBg" class="text-sm font-medium text-gray-300 cursor-pointer">Activar</label>
                    </div>
                </div>
                <div class="pl-4 border-l border-gray-700 mt-2">
                    <label id="textBgColorLabel" for="textBgColor" class="block text-sm font-medium text-gray-400 mb-2 mt-2 disabled:text-gray-600">Color de Fondo del Texto</label>
                    <input type="color" id="textBgColor" value="#000000" class="w-full h-8 border border-gray-600 bg-gray-700 p-1 cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed disabled:bg-gray-800">
                </div>
            </div>
            <div class="mb-4">
                <div class="flex items-center justify-between space-x-2">
                    <label for="toggleTextOutline" class="text-sm font-medium text-gray-300 cursor-pointer">Contorno del Texto</label>
                    <div class="flex items-center space-x-2">
                        <input type="checkbox" id="toggleTextOutline" class="h-4 w-4 text-purple-600 bg-gray-700 border-gray-600 focus:ring-purple-500">
                        <label for="toggleTextOutline" class="text-sm font-medium text-gray-300 cursor-pointer">Activar</label>
                    </div>
                </div>
                <div class="pl-4 border-l border-gray-700 mt-2">
                    <label id="textOutlineColorLabel" for="textOutlineColor" class="block text-sm font-medium text-gray-400 mb-2 mt-2 disabled:text-gray-600">Color del Contorno</label>
                    <input type="color" id="textOutlineColor" value="#000000" class="w-full h-8 border border-gray-600 bg-gray-700 p-1 cursor-pointer disabled:opacity-50 disabled:cursor-not-allowed disabled:bg-gray-800">
                    <label id="outlineThicknessLabel" for="outlineThicknessRange" class="block text-sm font-medium text-gray-400 mb-2 mt-4 disabled:text-gray-600">Grosor del Contorno</label>
                    <div class="flex items-center space-x-2">
                        <input type="range" id="outlineThicknessRange" min="0" max="5" step="0.1" value="0" disabled class="w-full h-2 bg-gray-700 appearance-none cursor-pointer range-shadow">
                        <span id="outlineThicknessValue" class="text-xs text-gray-400 w-10 text-right">0px</span>
                    </div>
                </div>
            </div>
        </div>
        <div id="tab-content-audio" class="tab-content flex-grow px-4">
            <div class="text-xs text-gray-400 mb-2">
                *Al añadir un AUDIO, el Server se desconectará durante 5s. El audio no se escuchará hasta que se vuelva a conectar el Server*
            </div>
            <h2 class="text-lg font-semibold mb-4 text-purple-400">Controles de Audio</h2>
            <span id="currentAudioName" class="block text-sm font-medium text-gray-400 mb-2"></span>
            <div class="flex items-center justify-center space-x-4 mb-4">
                <button id="playPauseBtn" disabled class="bg-purple-600 hover:bg-purple-700 text-white font-bold p-3 rounded-full shadow-md transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                    <svg id="playIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6">
                        <path fill-rule="evenodd" d="M4.5 5.653c0-1.426 1.529-2.38 2.872-1.667l11.553 6.917c1.164.696 1.164 2.67 0 3.366l-11.553 6.917C6.029 21.38 4.5 20.426 4.5 19.0V5.653Z" clip-rule="evenodd" />
                    </svg>
                    <svg id="pauseIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6 hidden">
                        <path fill-rule="evenodd" d="M6.75 5.25a.75.75 0 0 1 .75-.75H9a.75.75 0 0 1 .75.75v13.5a.75.75 0 0 1-.75.75H7.5a.75.75 0 0 1-.75-.75V5.25ZM14.25 5.25a.75.75 0 0 1 .75-.75h1.5a.75.75 0 0 1 .75.75v13.5a.75.75 0 0 1-.75.75h-1.5a.75.75 0 0 1-.75-.75V5.25Z" clip-rule="evenodd" />
                    </svg>
                </button>
            </div>
            <div id="audioCountdown" class="text-xs text-gray-400 mt-2 text-center" style="display: none;"></div>
            <div class="mb-4">
                <label for="volumeRange" class="block text-sm font-medium text-gray-300 mb-2">Volumen</label>
                <div class="flex items-center space-x-2">
                    <input type="range" id="volumeRange" min="0" max="1" step="0.01" value="0.5" disabled class="w-full h-2 bg-gray-700 appearance-none cursor-pointer range-shadow">
                    <span id="volumeValue" class="text-xs text-gray-400 w-10 text-right">50%</span>
                </div>
            </div>
            <div class="mb-4">
                <label for="timelineRange" class="block text-sm font-medium text-gray-300 mb-2">Línea de tiempo</label>
                <div class="flex items-center space-x-2">
                    <input type="range" id="timelineRange" min="0" max="100" step="0.1" value="0" disabled class="w-full h-2 bg-gray-700 appearance-none cursor-pointer range-shadow">
                    <span id="currentTimeDisplay" class="text-xs text-gray-400 w-16 text-right">0:00 / 0:00</span>
                </div>
            </div>
            <h3 class="text-md font-semibold mb-2 text-purple-400 mt-6">Audios Subidos</h3>
            <div id="audioPlaylist" class="space-y-2">
                <p class="text-gray-400 text-sm">No hay audios subidos.</p>
            </div>
        </div>
        <div id="tab-content-layers" class="tab-content flex-grow px-4">
            <h2 class="text-lg font-semibold mb-4 text-purple-400">Capas de Elementos</h2>
            <div id="layersList" class="space-y-2">
                <p class="text-gray-400 text-sm">No hay elementos en la página.</p>
            </div>
        </div>
    </aside>
    <main id="editorCanvas" class="relative m-4 shadow-inner">
        <div id="mainCanvasWrapper">
            <div id="leftSidebar"></div>
            <div id="innerCanvas">
            </div>
        </div>
    </main>
    <div class="absolute bottom-4 right-4 bg-gray-800 p-2 rounded-lg shadow-xl z-50 flex items-center space-x-2 zoom-controls">
        <label for="newZoomRange" class="text-sm font-medium text-gray-300">Zoom</label>
        <input type="range" id="newZoomRange" min="0.25" max="2.0" step="0.05" value="1.0" class="w-24 h-2 bg-gray-700 appearance-none cursor-pointer">
        <span id="zoomValue" class="text-xs text-gray-400">100%</span>
    </div>
    <script>
        const editorCanvas = document.getElementById('editorCanvas');
        const mainCanvasWrapper = document.getElementById('mainCanvasWrapper');
        const leftSidebar = document.getElementById('leftSidebar');
        const innerCanvas = document.getElementById('innerCanvas');
        const sidebar = document.querySelector('aside');
        const imageUpload = document.getElementById('imageUpload');
        const addTextBtn = document.getElementById('addTextBtn');
        const textInput = document.getElementById('textInput');
        const opacityRange = document.getElementById('opacityRange');
        const opacityValue = document.getElementById('opacityValue');
        const rotationRange = document.getElementById('rotationRange');
        const rotationValue = document.getElementById('rotationValue');
        const sizeRange = document.getElementById('sizeRange');
        const sizeValue = document.getElementById('sizeValue');
        const resetSizeBtn = document.getElementById('resetSizeBtn');
        const duplicateElementBtn = document.getElementById('duplicateElementBtn');
        const deleteElementBtn = document.getElementById('deleteElementBtn');
        const layersList = document.getElementById('layersList');
        const bringToFrontBtn = document.getElementById('bringToFrontBtn');
        const textColorInput = document.getElementById('textColor');
        const textBgColorInput = document.getElementById('textBgColor');
        const boldTextBtn = document.getElementById('boldTextBtn');
        const italicTextBtn = document.getElementById('italicTextBtn');
        const toggleTextBg = document.getElementById('toggleTextBg');
        const toggleTextOutline = document.getElementById('toggleTextOutline');
        const textOutlineColorInput = document.getElementById('textOutlineColor');
        const outlineThicknessRange = document.getElementById('outlineThicknessRange');
        const outlineThicknessValue = document.getElementById('outlineThicknessValue');
        const fontSizeRange = document.getElementById('fontSizeRange');
        const fontSizeValue = document.getElementById('fontSizeValue');
        const resetOpacityBtn = document.getElementById('resetOpacityBtn');
        const resetRotationBtn = document.getElementById('resetRotationBtn');
        const audioControlsSection = document.getElementById('tab-content-audio');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const playIcon = document.getElementById('playIcon');
        const pauseIcon = document.getElementById('pauseIcon');
        const volumeRange = document.getElementById('volumeRange');
        const volumeValueDisplay = document.getElementById('volumeValue');
        const currentAudioNameDisplay = document.getElementById('currentAudioName');
        const audioPlaylist = document.getElementById('audioPlaylist');
        const fileLimit = 50;
        const fileCountDisplay = document.getElementById('fileCountDisplay');
        const selectFileButtonText = document.getElementById('selectFileButtonText');
        const textBgColorLabel = document.getElementById('textBgColorLabel');
        const textOutlineColorLabel = document.getElementById('textOutlineColorLabel');
        const outlineThicknessLabel = document.getElementById('outlineThicknessLabel');
        const zoomRange = document.getElementById('newZoomRange');
        const zoomValue = document.getElementById('zoomValue');
        const dropArea = document.getElementById('dropArea');
        const wsStatusElement = document.getElementById('wsStatus');
        const mutePreferenceModal = document.getElementById('mutePreferenceModal');
        const modalMuteBtn = document.getElementById('modalMuteBtn');
        const modalSoundBtn = document.getElementById('modalSoundBtn');
        const audioCountdown = document.getElementById('audioCountdown');
        const timelineRange = document.getElementById('timelineRange');
        const currentTimeDisplay = document.getElementById('currentTimeDisplay');


        let selectedElementWrapper = null;
        let selectedAudioElement = null;
        let isDragging = false;
        let isResizing = false;
        let isRotating = false;
        let activeHandle = '';
        let initialMouseX, initialMouseY;
        let initialLeft, initialTop, initialWidth, initialHeight;
        let initialRotationAngle = 0;
        let initialElementRotation = 0;
        let currentZoom = 1.0;
        let isMutedGlobally = true;
        const allElements = new Map();
        const WS_URL = 'wss://pagina-mods-websocket-server.onrender.com';
        let ws = null;
        let reconnectInterval = null;
        let audioCountdownInterval = null;

        let myUserId = 'user-' + Math.random().toString(36).substr(2, 9);
        let myUserColor = getRandomColor();

        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        const DRAG_SEND_THROTTLE_MS = 80; 
        let dragSendTimeout = null;
        let pendingDOMUpdateAnimationFrame = null;

        const ELEMENT_VISIBILITY_DELAY_MS = 2000;

        function connectWebSocket() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                return;
            }
            updateWsStatus('connecting');


            if (reconnectInterval) {
                clearInterval(reconnectInterval);
                reconnectInterval = null;
            }

            try {
                ws = new WebSocket(WS_URL);
            } catch (e) {
                if (!reconnectInterval) {
                    reconnectInterval = setInterval(connectWebSocket, 5000);
                }
                return;
            }


            ws.onopen = () => {
                updateWsStatus('connected');
                if (reconnectInterval) {
                    clearInterval(reconnectInterval);
                    reconnectInterval = null;
                }
                sendWebSocketMessage('userConnect', { userId: myUserId, userName: `Usuario ${myUserId.slice(-4)}`, userColor: myUserColor });
            };

            ws.onmessage = (event) => {
                const message = JSON.parse(event.data);
                if (message.type === 'initialState') {
                    allElements.clear();
                    mainCanvasWrapper.querySelectorAll('.element-wrapper').forEach(el => el.remove());
                    audioPlaylist.innerHTML = '<p class="text-gray-400 text-sm">No hay audios subidos.</p>';
                    selectedAudioElement = null; 
                    if (audioCountdownInterval) {
                        clearInterval(audioCountdownInterval);
                        audioCountdownInterval = null;
                    }
                    audioCountdown.style.display = 'none';

                    message.elements.forEach(data => {
                        if (data.type === 'audio') {
                            if (!data.readyTimestamp) {
                                data.readyTimestamp = Date.now();
                            }
                            createAudioElementAndAddToPlaylist(data);
                        } else {
                            createElementFromData(data);
                        }
                    });

                    updateLayersList();
                    updateAudioPlaylistDisplay();
                    updateFileCountDisplay(); 
                } else if (message.type === 'elementAdd') {

                    if (allElements.has(message.element.id)) {
                        updateElementFromData(message.element);
                    } else {
                        if (message.element.type === 'audio') {
                            if (!message.element.readyTimestamp) {
                                message.element.readyTimestamp = Date.now();
                            }
                            createAudioElementAndAddToPlaylist(message.element);
                        } else {
                            createElementFromData(message.element);
                        }
                    }
                    updateLayersList();
                    updateAudioPlaylistDisplay();
                    updateFileCountDisplay();
                } else if (message.type === 'elementUpdate') {
                    updateElementFromData(message.element);
                    updateLayersList();
                    updateAudioPlaylistDisplay();
                } else if (message.type === 'elementDelete') {
                    deleteElementFromData(message.elementId);
                    updateLayersList();
                    updateAudioPlaylistDisplay();
                    updateFileCountDisplay();
                } else if (message.type === 'reorderLayers') {
                    message.elements.forEach(elementData => {
                        const elementWrapper = allElements.get(elementData.id);
                        if (elementWrapper && elementWrapper.style) {
                            elementWrapper.style.zIndex = elementData.zIndex;
                        }
                    });
                    updateLayersList();
                } else if (message.type === 'ping') {
                } else {
                }
            };

            ws.onclose = (event) => {
                ws = null;
                updateWsStatus('disconnected');
                if (!reconnectInterval) {
                    reconnectInterval = setInterval(connectWebSocket, 5000);
                }
                sendWebSocketMessage('userDisconnect', { userId: myUserId });
            };

            ws.onerror = (err) => {
            };
        }

        function sendWebSocketMessage(type, data) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                try {
                    ws.send(JSON.stringify({ type, ...data }));
                } catch (e) {
                }
            } else {
            }
        }

        function updateWsStatus(status) {
            wsStatusElement.classList.remove('connected', 'disconnected', 'connecting');
            if (status === 'connected') {
                wsStatusElement.classList.add('connected');
                wsStatusElement.textContent = 'Conectado';
            } else if (status === 'disconnected') {
                wsStatusElement.classList.add('disconnected');
                wsStatusElement.textContent = 'Desconectado';
            } else if (status === 'connecting') {
                wsStatusElement.classList.add('connecting');
                wsStatusElement.textContent = 'Conectando...';
            }
        }

        function generateUniqueId() {
            return 'element-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        }

        function getNextHighestZIndex() {
            let maxZ = 0;
            mainCanvasWrapper.querySelectorAll('.element-wrapper').forEach(elementWrapper => {
                const currentZ = parseInt(elementWrapper.style.zIndex || 0);
                if (currentZ > maxZ) {
                    maxZ = currentZ;
                }
            });
            return maxZ + 1;
        }

        function applyZoom() {
            mainCanvasWrapper.style.transform = `scale(${currentZoom})`;
            mainCanvasWrapper.style.transformOrigin = 'center center';
            zoomValue.textContent = `${Math.round(currentZoom * 100)}%`;
        }

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}`;
        }

        function generateTextShadowForOutline(thickness, color) {
            if (parseFloat(thickness) === 0) return 'none';
            const t = parseFloat(thickness);
            let shadow = [];
            shadow.push(`${-t}px ${-t}px 0 ${color}`);
            shadow.push(`${0}px ${-t}px 0 ${color}`);
            shadow.push(`${t}px ${-t}px 0 ${color}`);
            shadow.push(`${-t}px ${0}px 0 ${color}`);
            shadow.push(`${t}px ${0}px 0 ${color}`);
            shadow.push(`${-t}px ${t}px 0 ${color}`);
            shadow.push(`${0}px ${t}px 0 ${color}`);
            shadow.push(`${t}px ${t}px 0 ${color}`);
            return shadow.join(', ');
        }

        function adjustTextElementWrapperSize(elementWrapper) {
            const textElement = elementWrapper.querySelector('.element-content');
            if (!textElement) return;

            const computedStyle = window.getComputedStyle(textElement);
            const tempDiv = document.createElement('div');
            tempDiv.style.position = 'absolute';
            tempDiv.style.visibility = 'hidden';
            tempDiv.style.left = '-9999px';
            tempDiv.style.top = '-9999px';
            tempDiv.style.height = 'auto';
            tempDiv.style.width = 'auto';
            tempDiv.style.whiteSpace = 'pre-wrap';
            tempDiv.style.wordBreak = 'break-word';
            tempDiv.style.boxSizing = 'border-box';
            tempDiv.style.lineHeight = '1';
            tempDiv.style.textAlign = 'center';
            tempDiv.style.display = 'flex';
            tempDiv.style.alignItems = 'center';
            tempDiv.style.justifyContent = 'center';

            tempDiv.style.fontSize = computedStyle.fontSize;
            tempDiv.style.fontWeight = computedStyle.fontWeight;
            tempDiv.style.fontStyle = computedStyle.fontStyle;
            tempDiv.style.fontFamily = computedStyle.fontFamily;
            tempDiv.style.color = computedStyle.color;
            tempDiv.style.backgroundColor = computedStyle.backgroundColor;

            const outlineThickness = parseFloat(textElement.style.webkitTextStrokeWidth) || 0;
            const outlineColor = textElement.style.webkitTextStrokeColor || '#000000';
            if (outlineThickness > 0) {
                tempDiv.style.webkitTextStrokeWidth = `${outlineThickness}px`;
                tempDiv.style.webkitTextStrokeColor = outlineColor;
                tempDiv.style.textShadow = generateTextShadowForOutline(outlineThickness, outlineColor);
            } else {
                tempDiv.style.webkitTextStrokeWidth = '0';
                tempDiv.style.webkitTextStrokeColor = 'transparent';
                tempDiv.style.textShadow = 'none';
            }

            tempDiv.textContent = textElement.textContent;
            document.body.appendChild(tempDiv);

            const rawTextRect = tempDiv.getBoundingClientRect();
            const rawContentWidth = rawTextRect.width;
            const rawContentHeight = rawTextRect.height;

            document.body.removeChild(tempDiv);

            const wrapperPaddingHorizontal = 25;
            const wrapperPaddingVertical = 10;

            elementWrapper.style.width = `${rawContentWidth + (wrapperPaddingHorizontal * 2)}px`;
            elementWrapper.style.height = `${rawContentHeight + (wrapperPaddingVertical * 2)}px`;
            elementWrapper.style.padding = `${wrapperPaddingVertical}px ${wrapperPaddingHorizontal}px`;
            textElement.style.padding = '0px';
        }

        function saveElementsState() {
            localStorage.setItem('isMutedGlobally', JSON.stringify(isMutedGlobally));
        }

        function loadElementsState() {
            const storedMuteState = localStorage.getItem('isMutedGlobally');
            if (storedMuteState !== null) {
                isMutedGlobally = JSON.parse(storedMuteState);
            } else {
                isMutedGlobally = false; 
            }
        }

        function applyElementTransform(element, rotation, scale) {
            element.style.transform = `rotate(${rotation}deg) scale(${scale})`;
        }

        function createElementFromData(data) {
            if (allElements.has(data.id)) {
                const existingElement = allElements.get(data.id);
                if (existingElement.classList && existingElement.classList.contains('element-wrapper')) {
                    updateElementFromData(data);
                    return;
                }
            }
            if (data.type === 'audio') {
                createAudioElementAndAddToPlaylist(data);
                return;
            }

            const wrapperDiv = document.createElement('div');
            wrapperDiv.id = data.id;
            wrapperDiv.classList.add('element-wrapper');
            if (data.type === 'text') {
                wrapperDiv.classList.add('text-element-wrapper');
            }

            wrapperDiv.style.left = data.left;
            wrapperDiv.style.top = data.top;
            applyElementTransform(wrapperDiv, data.rotation || 0, data.scale || 1);
            wrapperDiv.style.zIndex = data.zIndex;
            
            const isReady = (data.readyForInteraction === 'true');
            wrapperDiv.style.opacity = isReady ? data.opacity : '0';
            wrapperDiv.style.pointerEvents = isReady ? 'auto' : 'none'; 
            wrapperDiv.dataset.readyForInteraction = data.readyForInteraction;
            wrapperDiv.dataset.readyTimestamp = data.readyTimestamp;

            if (data.originalName) {
                wrapperDiv.dataset.originalName = data.originalName;
            }
            if (data.initialAspectRatio) {
                wrapperDiv.dataset.initialAspectRatio = data.initialAspectRatio;
            }
            if (data.publicId) {
                wrapperDiv.dataset.publicId = data.publicId;
            }

            let contentElement;
            if (data.type === 'img' || data.type === 'gif') {
                contentElement = document.createElement('img');
                contentElement.src = data.src;
                contentElement.alt = data.originalName || 'Image';
                contentElement.classList.add('element-content');
                
                wrapperDiv.style.width = data.width;
                wrapperDiv.style.height = data.height;

                contentElement.onload = () => {
                };
                if (contentElement.complete) {
                    contentElement.onload();
                }

            } else if (data.type === 'text') {
                contentElement = document.createElement('div');
                contentElement.classList.add('text-content');
                contentElement.classList.add('element-content');
                contentElement.contentEditable = true;
                contentElement.textContent = data.textContent;
                contentElement.style.color = data.color;
                contentElement.style.backgroundColor = data.backgroundColor;
                contentElement.style.fontSize = data.fontSize;
                contentElement.spellcheck = false;

                wrapperDiv.style.width = data.width;
                wrapperDiv.style.height = data.height;

                if (data.isBold) contentElement.classList.add('font-bold');
                if (data.isItalic) contentElement.classList.add('italic');

                if (data.hasTextOutline && parseFloat(data.outlineThickness) > 0) {
                    contentElement.style.webkitTextStrokeWidth = data.outlineThickness;
                    contentElement.style.webkitTextStrokeColor = data.outlineColor;
                    contentElement.style.textShadow = generateTextShadowForOutline(parseFloat(data.outlineThickness), data.outlineColor);
                } else {
                    contentElement.style.webkitTextStrokeWidth = '0';
                    contentElement.style.webkitTextStrokeColor = 'transparent';
                    contentElement.style.textShadow = 'none';
                }
            } else {
                return;
            }

            wrapperDiv.appendChild(contentElement);
            addHandles(wrapperDiv);
            mainCanvasWrapper.appendChild(wrapperDiv);
            allElements.set(wrapperDiv.id, wrapperDiv);

            if (data.type === 'text') {
                adjustTextElementWrapperSize(wrapperDiv);
            }

            if (!isReady && data.readyTimestamp) {
                const delay = data.readyTimestamp - Date.now();
                if (delay > 0) {
                    setTimeout(() => {
                        wrapperDiv.style.opacity = '1';
                        wrapperDiv.style.pointerEvents = 'auto';
                        wrapperDiv.dataset.readyForInteraction = 'true';
                    }, delay);
                } else {
                    wrapperDiv.style.opacity = '1';
                    wrapperDiv.style.pointerEvents = 'auto';
                    wrapperDiv.dataset.readyForInteraction = 'true';
                }
            }
        }

        function createAudioElementAndAddToPlaylist(data) {
            let audioElement = allElements.get(data.id);
            if (!audioElement) {
                audioElement = document.createElement('audio');
                audioElement.id = data.id;
                audioElement.src = data.src;
                audioElement.volume = data.volume || 0.5;
                audioElement.currentTime = data.currentTime || 0;
                audioElement.dataset.lastVolume = data.lastVolume || 0.5;
                audioElement.muted = isMutedGlobally;
                audioElement.dataset.originalName = data.originalName || `Audio ${data.id.substring(data.id.length - 4)}`;
                audioElement.dataset.type = 'audio';
                audioElement.dataset.readyTimestamp = data.readyTimestamp || Date.now();
                audioElement.dataset.readyForInteraction = data.readyForInteraction;
                if (data.publicId) {
                    audioElement.dataset.publicId = data.publicId;
                }
                audioElement.preload = "metadata";

                const receivedReadyTime = parseFloat(audioElement.dataset.readyTimestamp || 0);
                if (audioElement.dataset.readyForInteraction === 'false' && receivedReadyTime <= Date.now()) {
                    audioElement.dataset.readyForInteraction = 'true';
                }


                audioElement.addEventListener('loadedmetadata', () => {
                    if (isNaN(audioElement.duration)) {
                        audioElement.duration = data.duration || audioElement.duration;
                    }
                    if (selectedAudioElement && selectedAudioElement.id === audioElement.id) {
                        timelineRange.max = audioElement.duration;
                        currentTimeDisplay.textContent = `${formatTime(audioElement.currentTime)} / ${formatTime(audioElement.duration)}`;
                    }
                });

                audioElement.addEventListener('timeupdate', () => {
                    if (selectedAudioElement && selectedAudioElement.id === audioElement.id && !isDraggingTimeline) {
                        timelineRange.value = audioElement.currentTime;
                        currentTimeDisplay.textContent = `${formatTime(audioElement.currentTime)} / ${formatTime(audioElement.duration)}`;
                    }
                });

                audioElement.addEventListener('ended', () => {
                    if (selectedAudioElement && selectedAudioElement.id === audioElement.id) {
                        updatePlayPauseButton(true);
                        audioElement.currentTime = 0;
                        sendWebSocketMessage('elementUpdate', {
                            element: {
                                ...getElementState(audioElement),
                                isPlaying: false,
                                paused: true 
                            }
                        });
                    }
                });

                allElements.set(audioElement.id, audioElement);
                if (data.isLocalUpload !== true) {
                    addAudioItemToPlaylistUI(audioElement);
                }

            } else {
                const elementToUpdate = allElements.get(data.id);
                elementToUpdate.src = data.src;
                elementToUpdate.volume = data.volume;
                elementToUpdate.muted = isMutedGlobally;
                elementToUpdate.dataset.lastVolume = data.lastVolume;
                elementToUpdate.dataset.readyTimestamp = data.readyTimestamp || elementToUpdate.dataset.readyTimestamp; 
                elementToUpdate.dataset.readyForInteraction = data.readyForInteraction;
                if (data.publicId) {
                    elementToUpdate.dataset.publicId = data.publicId;
                }

                const receivedReadyTime = parseFloat(elementToUpdate.dataset.readyTimestamp || 0);
                if (elementToUpdate.dataset.readyForInteraction === 'false' && receivedReadyTime <= Date.now()) {
                    elementToUpdate.dataset.readyForInteraction = 'true';
                }

                const timeDifference = Math.abs(elementToUpdate.currentTime - data.currentTime);
                if (elementToUpdate.paused || timeDifference > 0.5) {
                    elementToUpdate.currentTime = data.currentTime;
                }


                const isReady = (elementToUpdate.dataset.readyForInteraction === 'true');
                const shouldBePlayingAccordingToServer = data.isPlaying;


                if (shouldBePlayingAccordingToServer && isReady) {
                    if (elementToUpdate.paused) { 
                        elementToUpdate.play().catch(e => console.warn(`Autoplay blocked for ${elementToUpdate.id} during update:`, e));
                    } else {
                    }
                } else if (!shouldBePlayingAccordingToServer) {
                    if (!elementToUpdate.paused) { 
                        elementToUpdate.pause();
                    } else {
                    }
                }
            }
        }

        function addAudioItemToPlaylistUI(audioElement) {
            const noAudioMessage = audioPlaylist.querySelector('p');
            if (noAudioMessage) {
                noAudioMessage.remove();
            }

            let audioItemDiv = audioPlaylist.querySelector(`.audio-list-item[data-id="${audioElement.id}"]`);
            if (audioItemDiv) {
                audioItemDiv.querySelector('span').textContent = audioElement.dataset.originalName;
            } else {
                audioItemDiv = document.createElement('div');
                audioItemDiv.classList.add('audio-list-item');
                audioItemDiv.dataset.id = audioElement.id;

                const audioNameSpan = document.createElement('span');
                audioNameSpan.textContent = audioElement.dataset.originalName;
                audioNameSpan.classList.add('flex-1', 'truncate');
                audioItemDiv.appendChild(audioNameSpan);

                const controlsDiv = document.createElement('div');
                controlsDiv.classList.add('flex', 'space-x-2');

                const deleteAudioBtn = document.createElement('button');
                deleteAudioBtn.classList.add('text-white', 'p-1', 'rounded-full', 'bg-red-600', 'hover:bg-red-700', 'transition-colors');
                deleteAudioBtn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-4 h-4">
                        <path fill-rule="evenodd" d="M5.47 5.47a.75.75 0 0 1 1.06 0L12 10.94l5.47-5.47a.75.75 0 1 1 1.06 1.06L13.06 12l5.47 5.47a.75.75 0 1 1-1.06 1.06L12 13.06l-5.47 5.47a.75.75 0 0 1-1.06-1.06L10.94 12 5.47 6.53a.75.75 0 0 1 0-1.06Z" clip-rule="evenodd" />
                    </svg>
                `;
                controlsDiv.appendChild(deleteAudioBtn);

                audioItemDiv.appendChild(controlsDiv);
                audioPlaylist.appendChild(audioItemDiv);

                audioItemDiv.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectAudioElement(audioElement);
                });

                deleteAudioBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteElementFromData(audioElement.id);
                    sendWebSocketMessage('elementDelete', { elementId: audioElement.id });
                });
            }
        }


        function updateElementFromData(data) {
            const element = allElements.get(data.id);
            let contentElement = null; 

            if (!element) {
                if (data.type === 'audio') {
                    createAudioElementAndAddToPlaylist(data);
                } else {
                    createElementFromData(data);
                }
                return;
            }

            if (data.type === 'audio') {
                element.src = data.src;
                element.volume = data.volume;
                element.muted = isMutedGlobally;
                element.dataset.lastVolume = data.lastVolume;
                element.dataset.readyTimestamp = data.readyTimestamp || element.dataset.readyTimestamp; 
                element.dataset.readyForInteraction = data.readyForInteraction;
                if (data.publicId) {
                    element.dataset.publicId = data.publicId;
                }

                const receivedReadyTime = parseFloat(element.dataset.readyTimestamp || 0);
                if (element.dataset.readyForInteraction === 'false' && receivedReadyTime <= Date.now()) {
                    element.dataset.readyForInteraction = 'true';
                }

                const timeDifference = Math.abs(element.currentTime - data.currentTime);
                if (!isDraggingTimeline && (element.paused || timeDifference > 0.5)) { 
                    element.currentTime = data.currentTime;
                }


                const isReady = (element.dataset.readyForInteraction === 'true');
                const shouldBePlayingAccordingToServer = data.isPlaying;


                if (shouldBePlayingAccordingToServer && isReady) {
                    if (element.paused) { 
                        element.play().catch(e => console.warn(`Autoplay blocked for ${element.id} during update:`, e));
                    } else {
                    }
                } else if (!shouldBePlayingAccordingToServer) {
                    if (!element.paused) { 
                        element.pause();
                    } else {
                    }
                }
            } else {
                element.style.left = data.left;
                element.style.top = data.top;
                element.style.width = data.width;
                element.style.height = data.height;
                applyElementTransform(element, data.rotation || 0, data.scale || 1);
                element.style.zIndex = data.zIndex;
                
                const isReady = (data.readyForInteraction === 'true');
                if (isReady) {
                    element.style.opacity = data.opacity;
                    element.style.pointerEvents = 'auto'; 
                    element.dataset.readyForInteraction = 'true';
                } else {
                    element.style.opacity = '0';
                    element.style.pointerEvents = 'none';
                    element.dataset.readyForInteraction = 'false';
                    element.dataset.readyTimestamp = data.readyTimestamp;
                    const delay = data.readyTimestamp - Date.now();
                    if (delay > 0) {
                        setTimeout(() => {
                            element.style.opacity = '1';
                            element.style.pointerEvents = 'auto';
                            element.dataset.readyForInteraction = 'true';
                        }, delay);
                    } else {
                        element.style.opacity = '1';
                        element.style.pointerEvents = 'auto';
                        element.dataset.readyForInteraction = 'true';
                    }
                }
                
                contentElement = element.querySelector('.element-content');
                if (contentElement) {
                    if (data.type === 'text') {
                        contentElement.textContent = data.textContent;
                        contentElement.style.color = data.color;
                        contentElement.style.backgroundColor = data.backgroundColor;
                        contentElement.style.fontSize = data.fontSize;
                        
                        if (data.isBold) contentElement.classList.add('font-bold');
                        else contentElement.classList.remove('font-bold');
                        
                        if (data.isItalic) contentElement.classList.add('italic');
                        else contentElement.classList.remove('italic');

                        if (data.hasTextOutline && parseFloat(data.outlineThickness) > 0) {
                            contentElement.style.webkitTextStrokeWidth = data.outlineThickness;
                            contentElement.style.webkitTextStrokeColor = data.outlineColor;
                            contentElement.style.textShadow = generateTextShadowForOutline(parseFloat(data.outlineThickness), data.outlineColor);
                        } else {
                            contentElement.style.webkitTextStrokeWidth = '0';
                            contentElement.style.webkitTextStrokeColor = 'transparent';
                            contentElement.style.textShadow = 'none';
                        }
                        adjustTextElementWrapperSize(element);
                    }
                }
            }

            if (selectedAudioElement && selectedAudioElement.id === data.id) {
                volumeRange.value = element.volume;
                volumeValueDisplay.textContent = `${Math.round(element.volume * 100)}%`;
                updatePlayPauseButton(element.paused);
                currentAudioNameDisplay.textContent = element.dataset.originalName || 'Audio Seleccionado';
                checkAudioReadyState(selectedAudioElement);
                if (!isDraggingTimeline) {
                    timelineRange.value = element.currentTime;
                    timelineRange.max = element.duration;
                    currentTimeDisplay.textContent = `${formatTime(element.currentTime)} / ${formatTime(element.duration)}`;
                }
            } else if (selectedElementWrapper && selectedElementWrapper.id === data.id) {
                if (contentElement) { 
                    opacityRange.value = parseFloat(element.style.opacity) || 1;
                    opacityValue.textContent = `${Math.round(opacityRange.value * 100)}%`;
                    rotationRange.value = data.rotation;
                    rotationValue.textContent = `${Math.round(data.rotation)}°`;
                    sizeRange.value = data.scale;
                    sizeValue.textContent = `${Math.round(data.scale * 100)}%`;
                }
            }
            updateAudioPlaylistDisplay();
        }

        function deleteElementFromData(elementId) {
            const element = allElements.get(elementId);
            if (element) {
                if (element.tagName === 'AUDIO') {
                    element.pause();
                    element.src = '';
                    element.load();
                    const listItem = audioPlaylist.querySelector(`.audio-list-item[data-id="${elementId}"]`);
                    if (listItem) {
                        listItem.remove();
                    } else {
                    }
                    if (selectedAudioElement && selectedAudioElement.id === elementId) {
                        selectedAudioElement = null;
                        deselectAudioControls();
                    }
                    allElements.delete(elementId);
                    updateAudioPlaylistDisplay();
                    updateFileCountDisplay();
                } else if (element.classList && element.classList.contains('element-wrapper')) {
                    const contentElement = element.querySelector('.element-content');
                    if (contentElement && contentElement.tagName === 'AUDIO') {
                        contentElement.pause();
                        contentElement.src = '';
                        contentElement.load();
                    }
                    element.remove();
                    if (selectedElementWrapper && selectedElementWrapper.id === elementId) {
                        deselectAllElements();
                    }
                    allElements.delete(elementId);
                    updateLayersList();
                    updateFileCountDisplay();
                }
            } else {
            }
        }

        function updatePlayPauseButton(isPaused) {
            if (isPaused) {
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
            } else {
                playIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
            }
        }

        function applyGlobalMuteState() {
            allElements.forEach(element => {
                if (element.tagName === 'AUDIO') {
                    element.muted = isMutedGlobally; 

                    const serverState = getElementState(element);
                    const isReady = (element.dataset.readyForInteraction === 'true');

                    if (serverState && serverState.isPlaying && element.paused && isReady) {
                        element.play().catch(e => console.warn(`Autoplay blocked for ${element.id} during global state apply:`, e));
                    }
                }
            });
            if (selectedAudioElement) {
                updatePlayPauseButton(selectedAudioElement.paused);
                volumeRange.value = selectedAudioElement.volume;
                volumeValueDisplay.textContent = `${Math.round(selectedAudioElement.volume * 100)}%`;
            }
            saveElementsState();
        }

        function deselectAllElements() {
            document.querySelectorAll('.element-wrapper').forEach(el => {
                el.classList.remove('selected');
                el.querySelectorAll('.resize-handle').forEach(handle => handle.style.display = 'none');
                el.querySelector('.rotation-handle').style.display = 'none';
            });
            document.querySelectorAll('.layer-item').forEach(item => item.classList.remove('selected'));

            selectedElementWrapper = null;

            opacityRange.value = 1;
            opacityValue.textContent = '100%';
            rotationRange.value = 0;
            rotationValue.textContent = '0°';
            sizeRange.value = 1;
            sizeValue.textContent = '100%';
            opacityRange.disabled = true;
            rotationRange.disabled = true;
            sizeRange.disabled = true;
            duplicateElementBtn.disabled = true;
            deleteElementBtn.disabled = true;
            resetOpacityBtn.disabled = true;
            resetRotationBtn.disabled = true;
            resetSizeBtn.disabled = true;
            bringToFrontBtn.disabled = true;

            textInput.value = '';
            textColorInput.value = '#FFFFFF';
            textBgColorInput.value = '#000000';
            toggleTextBg.checked = false;
            toggleTextOutline.checked = false;
            textOutlineColorInput.value = '#000000';
            outlineThicknessRange.value = 0;
            outlineThicknessValue.textContent = '0px';
            fontSizeRange.value = 24;
            fontSizeValue.textContent = '24px';
            boldTextBtn.classList.remove('active-style');
            italicTextBtn.classList.remove('active-style');
            
            textColorInput.disabled = false;
            boldTextBtn.disabled = false;
            italicTextBtn.disabled = false;
            toggleTextBg.disabled = false;
            toggleTextOutline.disabled = false;
            fontSizeRange.disabled = false;

            textBgColorInput.disabled = !toggleTextBg.checked;
            textBgColorLabel.classList.toggle('text-gray-600', !toggleTextBg.checked);
            textBgColorLabel.classList.toggle('text-gray-300', toggleTextBg.checked);
            textOutlineColorInput.disabled = !toggleTextOutline.checked;
            outlineThicknessRange.disabled = !toggleTextOutline.checked;
            textOutlineColorLabel.classList.toggle('text-gray-600', !toggleTextOutline.checked);
            textOutlineColorLabel.classList.toggle('text-gray-300', toggleTextOutline.checked);
            outlineThicknessLabel.classList.toggle('text-gray-600', !toggleTextOutline.checked);
            outlineThicknessLabel.classList.toggle('text-gray-300', toggleTextOutline.checked);

            document.querySelectorAll('.audio-list-item').forEach(item => item.classList.remove('selected'));
            deselectAudioControls();
        }

        function deselectAudioControls() {
            selectedAudioElement = null;
            playPauseBtn.disabled = true;
            volumeRange.disabled = true;
            timelineRange.disabled = true;
            timelineRange.value = 0;
            currentTimeDisplay.textContent = '0:00 / 0:00';
            currentAudioNameDisplay.textContent = '';
            volumeRange.value = 0.5;
            volumeValueDisplay.textContent = '50%';
            updatePlayPauseButton(true);

            if (audioCountdownInterval) {
                clearInterval(audioCountdownInterval);
                audioCountdownInterval = null;
            }
            audioCountdown.style.display = 'none';
            audioCountdown.textContent = '';
        }

        function checkAudioReadyState(audioElement) {
            if (!audioElement) return;

            const readyTime = parseFloat(audioElement.dataset.readyTimestamp || 0);
            const currentTime = Date.now();
            const rawTimeDiff = readyTime - currentTime;
            const timeRemaining = Math.max(0, Math.ceil(rawTimeDiff / 1000));


            if (audioElement.dataset.readyForInteraction === 'true') {
                playPauseBtn.disabled = false;
                timelineRange.disabled = false;
                if (audioCountdownInterval) {
                    clearInterval(audioCountdownInterval);
                    audioCountdownInterval = null;
                }
                audioCountdown.style.display = 'none';
                audioCountdown.textContent = '';
                return;
            }

            if (rawTimeDiff > 0) {
                playPauseBtn.disabled = true;
                timelineRange.disabled = true;
                audioCountdown.style.display = 'block';
                audioCountdown.textContent = `Reproducción en ${timeRemaining} segundos...`;

                if (audioCountdownInterval) {
                    clearInterval(audioCountdownInterval);
                }
                audioCountdownInterval = setInterval(() => {
                    const newRawTimeDiff = readyTime - Date.now();
                    const newTimeRemaining = Math.max(0, Math.ceil(newRawTimeDiff / 1000));
                    
                    if (newTimeRemaining > 0) {
                        audioCountdown.textContent = `Reproducción en ${newTimeRemaining} segundos...`;
                    } else {
                        clearInterval(audioCountdownInterval);
                        audioCountdownInterval = null;
                        audioCountdown.style.display = 'none';
                        audioCountdown.textContent = '';
                        playPauseBtn.disabled = false; 
                        timelineRange.disabled = false;
                        
                        if (audioElement.dataset.readyForInteraction !== 'true') {
                            audioElement.dataset.readyForInteraction = 'true';
                            const updatedState = getElementState(audioElement);
                            updatedState.readyForInteraction = 'true';
                            sendWebSocketMessage('elementUpdate', { element: updatedState });
                        }
                    }
                }, 1000);
            } else {
                audioCountdown.style.display = 'none';
                audioCountdown.textContent = '';
                playPauseBtn.disabled = false; 
                timelineRange.disabled = false;
                if (audioElement.dataset.readyForInteraction !== 'true') {
                    audioElement.dataset.readyForInteraction = 'true';
                    const updatedState = getElementState(audioElement);
                    updatedState.readyForInteraction = 'true';
                    sendWebSocketMessage('elementUpdate', { element: updatedState });
                }
            }
        }


        function selectElement(element) {
            deselectAllElements();

            if (element.classList && element.classList.contains('element-wrapper')) {
                const isReady = element.dataset.readyForInteraction === 'true';

                if (!isReady) {
                    showConfirmationModal('El elemento aún no está listo para interactuar. Espera un momento.', null);
                    return; 
                }

                selectedElementWrapper = element;
                selectedElementWrapper.classList.add('selected');

                const contentElement = selectedElementWrapper.querySelector('img.element-content, div.text-content.element-content');
                if (!contentElement) {
                    return;
                }

                selectedElementWrapper.querySelector('.rotation-handle').style.display = 'block';
                rotationRange.disabled = false;
                sizeRange.disabled = false;
                resetSizeBtn.disabled = false;

                if (!contentElement.classList.contains('text-content')) {
                    selectedElementWrapper.querySelectorAll('.resize-handle').forEach(handle => handle.style.display = 'block');
                } else {
                    selectedElementWrapper.querySelectorAll('.resize-handle').forEach(handle => handle.style.display = 'none');
                }

                opacityRange.disabled = false;
                duplicateElementBtn.disabled = false;
                deleteElementBtn.disabled = false;
                resetOpacityBtn.disabled = false;
                resetRotationBtn.disabled = false;
                bringToFrontBtn.disabled = false;

                opacityRange.value = parseFloat(selectedElementWrapper.style.opacity) || 1;
                opacityValue.textContent = `${Math.round(opacityRange.value * 100)}%`;
                
                const elementState = getElementState(selectedElementWrapper);
                rotationRange.value = elementState.rotation;
                rotationValue.textContent = `${Math.round(elementState.rotation)}°`;
                sizeRange.value = elementState.scale;
                sizeValue.textContent = `${Math.round(elementState.scale * 100)}%`;


                if (contentElement.classList.contains('text-content')) {
                    textInput.disabled = false; 
                    textInput.value = contentElement.textContent;
                    textColorInput.disabled = false;
                    boldTextBtn.disabled = false;
                    italicTextBtn.disabled = false;
                    toggleTextBg.disabled = false;
                    toggleTextOutline.disabled = false;
                    fontSizeRange.disabled = false;

                    textColorInput.value = contentElement.style.color || '#FFFFFF';

                    if (contentElement.style.backgroundColor === 'transparent') {
                        toggleTextBg.checked = false;
                        textBgColorInput.value = '#000000';
                        textBgColorInput.disabled = true;
                        textBgColorLabel.classList.add('text-gray-600');
                        textBgColorLabel.classList.remove('text-gray-300');
                    } else {
                        toggleTextBg.checked = true;
                        textBgColorInput.value = contentElement.style.backgroundColor || '#000000';
                        textBgColorInput.disabled = false;
                        textBgColorLabel.classList.remove('text-gray-600');
                        textBgColorLabel.classList.add('text-gray-300');
                    }

                    if (contentElement.style.webkitTextStrokeWidth && parseFloat(contentElement.style.webkitTextStrokeWidth) > 0) {
                        toggleTextOutline.checked = true;
                        textOutlineColorInput.value = contentElement.style.webkitTextStrokeColor || '#000000';
                        outlineThicknessRange.value = parseFloat(contentElement.style.webkitTextStrokeWidth);
                        outlineThicknessValue.textContent = `${outlineThicknessRange.value}px`;
                        textOutlineColorInput.disabled = false;
                        outlineThicknessRange.disabled = false;
                        textOutlineColorLabel.classList.remove('text-gray-600');
                        textOutlineColorLabel.classList.add('text-gray-300');
                        outlineThicknessLabel.classList.remove('text-gray-600');
                        outlineThicknessLabel.classList.add('text-gray-300');
                    } else {
                        toggleTextOutline.checked = false;
                        textOutlineColorInput.value = '#000000';
                        outlineThicknessRange.value = 0;
                        outlineThicknessValue.textContent = '0px';
                        textOutlineColorInput.disabled = true;
                        outlineThicknessRange.disabled = true;
                        textOutlineColorLabel.classList.add('text-gray-600');
                        textOutlineColorLabel.classList.remove('text-gray-300');
                        outlineThicknessLabel.classList.add('text-gray-600');
                        outlineThicknessLabel.classList.remove('text-gray-300');
                    }

                    fontSizeRange.value = parseFloat(contentElement.style.fontSize) || 24;
                    fontSizeValue.textContent = `${fontSizeRange.value}px`;

                    if (contentElement.classList.contains('font-bold')) {
                        boldTextBtn.classList.add('active-style');
                    } else {
                        boldTextBtn.classList.remove('active-style');
                    }
                    if (contentElement.classList.contains('italic')) {
                        italicTextBtn.classList.add('active-style');
                    } else {
                        italicTextBtn.classList.remove('active-style');
                    }
                    adjustTextElementWrapperSize(selectedElementWrapper);
                } else { 
                    textColorInput.disabled = true;
                    boldTextBtn.disabled = true;
                    italicTextBtn.disabled = true;
                    toggleTextBg.disabled = true;
                    toggleTextOutline.disabled = true;
                    fontSizeRange.disabled = true;
                    textBgColorInput.disabled = true;
                    textOutlineColorInput.disabled = true;
                    outlineThicknessRange.disabled = true;
                    textBgColorLabel.classList.add('text-gray-600');
                    textBgColorLabel.classList.remove('text-gray-300');
                    textOutlineColorLabel.classList.add('text-gray-600');
                    textOutlineColorLabel.classList.remove('text-gray-300');
                    outlineThicknessLabel.classList.add('text-gray-600');
                    outlineThicknessLabel.classList.remove('text-gray-300');
                }

                deselectAudioControls();

                const layerItem = document.querySelector(`.layer-item[data-id="${element.id}"]`);
                if (layerItem) {
                    layerItem.classList.add('selected');
                }
            }
        }

        function selectAudioElement(audioElement) {
            deselectAllElements(); 

            selectedAudioElement = audioElement;
            document.querySelectorAll('.audio-list-item').forEach(item => item.classList.remove('selected'));
            const listItem = audioPlaylist.querySelector(`.audio-list-item[data-id="${audioElement.id}"]`);
            if (listItem) {
                listItem.classList.add('selected');
            }

            opacityRange.disabled = true;
            rotationRange.disabled = true;
            sizeRange.disabled = true; 
            duplicateElementBtn.disabled = true;
            bringToFrontBtn.disabled = true;
            resetOpacityBtn.disabled = true;
            resetRotationBtn.disabled = true;
            resetSizeBtn.disabled = true; 

            textColorInput.disabled = true;
            boldTextBtn.disabled = true;
            italicTextBtn.disabled = true;
            toggleTextBg.disabled = true;
            toggleTextOutline.disabled = true;
            fontSizeRange.disabled = true;
            textBgColorInput.disabled = true;
            textOutlineColorInput.disabled = true;
            outlineThicknessRange.disabled = true;
            textBgColorLabel.classList.add('text-gray-600');
            textBgColorLabel.classList.remove('text-gray-300');
            textOutlineColorLabel.classList.add('text-gray-600');
            textOutlineColorLabel.classList.remove('text-gray-300');
            outlineThicknessLabel.classList.add('text-gray-600');
            outlineThicknessLabel.classList.remove('text-gray-300');


            volumeRange.disabled = false;
            timelineRange.disabled = false;
            deleteElementBtn.disabled = false;


            audioElement.muted = isMutedGlobally; 
            volumeRange.value = audioElement.volume;
            volumeValueDisplay.textContent = `${Math.round(audioElement.volume * 100)}%`;
            updatePlayPauseButton(audioElement.paused);
            currentAudioNameDisplay.textContent = audioElement.dataset.originalName || 'Audio Seleccionado';
            
            timelineRange.max = audioElement.duration || 0;
            timelineRange.value = audioElement.currentTime || 0;
            currentTimeDisplay.textContent = `${formatTime(audioElement.currentTime)} / ${formatTime(audioElement.duration)}`;

            checkAudioReadyState(audioElement);
        }


        function addHandles(elementWrapper) {
            const handles = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
            handles.forEach(pos => {
                const handle = document.createElement('div');
                handle.classList.add('resize-handle', pos);
                handle.style.display = 'none';
                elementWrapper.appendChild(handle);
            });

            const rotationHandle = document.createElement('div');
            rotationHandle.classList.add('rotation-handle');
            rotationHandle.style.display = 'none';
            elementWrapper.appendChild(rotationHandle);
        }

        function updateLayersList() {
            layersList.innerHTML = '';

            const visualElements = Array.from(allElements.values()).filter(el => el.classList && el.classList.contains('element-wrapper'));

            if (visualElements.length === 0) {
                layersList.innerHTML = '<p class="text-gray-400 text-sm">No hay elementos en la página.</p>';
                return;
            }

            const sortedElements = visualElements.sort((a, b) => {
                return (parseFloat(b.style.zIndex || 0)) - (parseFloat(a.style.zIndex || 0));
            });

            sortedElements.forEach(elementWrapper => {
                const contentElement = elementWrapper.querySelector('img.element-content, div.text-content.element-content');
                const layerItem = document.createElement('div');
                layerItem.classList.add('layer-item');
                layerItem.dataset.id = elementWrapper.id;

                let name;
                if (contentElement && contentElement.tagName === 'IMG') {
                    name = `Imagen: "${elementWrapper.dataset.originalName || contentElement.alt || elementWrapper.id}"`;
                } else if (contentElement && contentElement.classList.contains('text-content')) {
                    name = `Texto: "${contentElement.textContent.substring(0, 20)}${contentElement.textContent.length > 20 ? '...' : ''}"`;
                } else {
                    name = `Unknown element: ${elementWrapper.id}`;
                }
                layerItem.textContent = name;

                const isReady = elementWrapper.dataset.readyForInteraction === 'true';
                layerItem.style.opacity = isReady ? '1' : '0.5';
                layerItem.style.pointerEvents = isReady ? 'auto' : 'none';

                if (selectedElementWrapper && selectedElementWrapper.id === elementWrapper.id) {
                    layerItem.classList.add('selected');
                }

                layerItem.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectElement(elementWrapper);
                });

                const dragHandle = document.createElement('span');
                dragHandle.innerHTML = '&#9776;';
                dragHandle.classList.add('drag-handle', 'mr-2', 'cursor-move', 'text-gray-400', 'hover:text-white');
                dragHandle.setAttribute('draggable', 'true');
                layerItem.prepend(dragHandle);

                layersList.appendChild(layerItem);
            });
        }

        function updateAudioPlaylistDisplay() {
            audioPlaylist.innerHTML = '';

            const audioElements = Array.from(allElements.values()).filter(el => 
                el.tagName === 'AUDIO' && el.dataset.readyForInteraction === 'true'
            );

            if (audioElements.length === 0) {
                audioPlaylist.innerHTML = '<p class="text-gray-400 text-sm">No hay audios subidos.</p>';
                return;
            }

            audioElements.sort((a, b) => a.dataset.originalName.localeCompare(b.dataset.originalName)).forEach(audioElement => {
                addAudioItemToPlaylistUI(audioElement);
            });
        }


        function updateFileCountDisplay() {
            fileCountDisplay.textContent = `${allElements.size}/${fileLimit}`;
            if (allElements.size >= fileLimit) {
                imageUpload.disabled = true;
                imageUpload.parentElement.classList.add('opacity-50', 'cursor-not-allowed');
                imageUpload.parentElement.style.pointerEvents = 'none';
                selectFileButtonText.textContent = 'Límite alcanzado';
                imageUpload.parentElement.classList.remove('hover:bg-purple-700');
                dropArea.classList.add('opacity-50', 'cursor-not-allowed');
                dropArea.style.pointerEvents = 'none';
            } else {
                imageUpload.disabled = false;
                imageUpload.parentElement.classList.remove('opacity-50', 'cursor-not-allowed');
                imageUpload.parentElement.style.pointerEvents = 'auto';
                selectFileButtonText.textContent = 'Seleccionar archivo';
                imageUpload.parentElement.classList.add('hover:bg-purple-700');
                dropArea.classList.remove('opacity-50', 'cursor-not-allowed');
                dropArea.style.pointerEvents = 'auto';
            }
        }

        function handleFile(file) {
            if (allElements.size >= fileLimit) {
                return;
            }

            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    if (file.type.startsWith('audio/')) {
                        const tempAudio = document.createElement('audio');
                        tempAudio.src = e.target.result;
                        
                        let audioReadyPromise = new Promise((resolve, reject) => {
                            tempAudio.addEventListener('loadedmetadata', () => {
                                const maxAudioDurationSeconds = 480;
                                if (tempAudio.duration > maxAudioDurationSeconds) {
                                    showConfirmationModal(`Este MP3 dura más de 8 minutos (${formatTime(tempAudio.duration)}). Por favor, sube un archivo más corto.`, null);
                                    reject(new Error('Audio too long'));
                                    return;
                                }
                                resolve(tempAudio.duration);
                            }, { once: true });
                            tempAudio.addEventListener('error', (err) => {
                                reject(new Error('Error loading audio metadata'));
                            }, { once: true });
                        });

                        audioReadyPromise.then(duration => {
                            createLocalElementAndSend(file, e.target.result, duration, true);
                        }).catch(error => {
                        });
                        
                    } else {
                        createLocalElementAndSend(file, e.target.result);
                    }
                };
                reader.readAsDataURL(file);
            }
        }

        function createLocalElementAndSend(file, srcData, audioDuration = null, isLocalUpload = false) {
            const newId = generateUniqueId();
            let elementState = {
                id: newId,
                originalName: file.name
            };

            if (file.type.startsWith('image/') || file.type.startsWith('image/gif')) {
                const wrapperDiv = document.createElement('div');
                wrapperDiv.id = newId;
                wrapperDiv.classList.add('element-wrapper');
                wrapperDiv.style.minWidth = '50px';
                wrapperDiv.style.minHeight = '30px';
                wrapperDiv.style.zIndex = getNextHighestZIndex();
                applyElementTransform(wrapperDiv, 0, 1);
                wrapperDiv.style.opacity = '0';
                wrapperDiv.style.pointerEvents = 'none';
                wrapperDiv.dataset.readyForInteraction = 'false';
                const readyTime = Date.now() + ELEMENT_VISIBILITY_DELAY_MS;
                wrapperDiv.dataset.readyTimestamp = readyTime; 


                const contentElement = document.createElement('img');
                contentElement.src = srcData;
                contentElement.alt = file.name;
                contentElement.classList.add('element-content');
                
                wrapperDiv.appendChild(contentElement);
                
                contentElement.onload = () => {
                    const defaultInitialSize = 200;
                    let finalWidth = contentElement.naturalWidth;
                    let finalHeight = contentElement.naturalHeight;
                    const aspectRatio = finalWidth / finalHeight;

                    if (finalWidth > defaultInitialSize || finalHeight > defaultInitialSize) {
                        if (finalWidth / defaultInitialSize > finalHeight / defaultInitialSize) {
                            finalWidth = defaultInitialSize;
                            finalHeight = finalWidth / aspectRatio;
                        } else {
                            finalHeight = defaultInitialSize;
                            finalWidth = finalHeight * aspectRatio;
                        }
                    }

                    const greenCanvasCenterX = leftSidebar.offsetWidth / 2;
                    const greenCanvasCenterY = leftSidebar.offsetHeight / 2;
                    const initialLeft = greenCanvasCenterX - (finalWidth / 2);
                    const initialTop = greenCanvasCenterY - (finalHeight / 2);

                    wrapperDiv.style.left = `${initialLeft}px`;
                    wrapperDiv.style.top = `${initialTop}px`;
                    wrapperDiv.style.width = `${finalWidth}px`;
                    wrapperDiv.style.height = `${finalHeight}px`;
                    
                    addHandles(wrapperDiv);
                    
                    mainCanvasWrapper.appendChild(wrapperDiv); 
                    allElements.set(wrapperDiv.id, wrapperDiv);

                    wrapperDiv.dataset.initialAspectRatio = aspectRatio;

                    updateLayersList();
                    updateFileCountDisplay();
                    
                    elementState = {
                        ...elementState,
                        left: wrapperDiv.style.left,
                        top: wrapperDiv.style.top,
                        width: wrapperDiv.style.width,
                        height: wrapperDiv.style.height,
                        rotation: 0,
                        scale: 1,
                        zIndex: wrapperDiv.style.zIndex,
                        opacity: '1',
                        type: file.type.startsWith('image/gif') ? 'gif' : 'img', 
                        src: srcData,
                        initialAspectRatio: aspectRatio,
                        readyForInteraction: 'false',
                        readyTimestamp: readyTime
                    };
                    sendWebSocketMessage('elementAdd', { element: elementState });

                    setTimeout(() => {
                        wrapperDiv.style.opacity = '1';
                        wrapperDiv.style.pointerEvents = 'auto';
                        wrapperDiv.dataset.readyForInteraction = 'true';
                        updateLayersList();
                    }, ELEMENT_VISIBILITY_DELAY_MS);
                };
                if (contentElement.complete) {
                    contentElement.onload();
                }

            } else if (file.type.startsWith('audio/')) {
                const audioElement = document.createElement('audio');
                audioElement.id = newId;
                audioElement.src = srcData;
                audioElement.volume = 0.5;
                audioElement.currentTime = 0;
                audioElement.dataset.lastVolume = 0.5;
                audioElement.muted = isMutedGlobally;
                audioElement.dataset.originalName = file.name;
                audioElement.dataset.type = 'audio';
                audioElement.dataset.readyTimestamp = Date.now();
                audioElement.dataset.readyForInteraction = 'true';
                if (audioDuration !== null) {
                    audioElement.duration = audioDuration; 
                }

                allElements.set(audioElement.id, audioElement); 
                updateFileCountDisplay();
                addAudioItemToPlaylistUI(audioElement);

                const initialElementState = {
                    ...elementState,
                    type: 'audio', src: srcData, volume: audioElement.volume, currentTime: audioElement.currentTime,
                    paused: true, isPlaying: false, duration: audioDuration || 0, lastVolume: audioElement.dataset.lastVolume,
                    readyTimestamp: parseFloat(audioElement.dataset.readyTimestamp), 
                    left: '0px', top: '0px', width: '0px', height: '0px',
                    rotation: 0, scale: 1, zIndex: 0, opacity: 1, visibility: 'hidden', 
                    readyForInteraction: 'true',
                    isLocalUpload: true 
                };
                sendWebSocketMessage('elementAdd', { element: initialElementState });

            }
        }


        imageUpload.addEventListener('change', (event) => {
            if (event.target.files.length > 0) {
                handleFile(event.target.files[0]);
                event.target.value = '';
            }
        });

        addTextBtn.addEventListener('click', () => {
            if (allElements.size >= fileLimit) {
                return;
            }

            const textContent = textInput.value.trim() === '' ? 'New Text' : textInput.value;
            const newId = generateUniqueId();

            const wrapperDiv = document.createElement('div');
            wrapperDiv.id = newId;
            wrapperDiv.classList.add('element-wrapper', 'text-element-wrapper');

            const greenCanvasCenterX = leftSidebar.offsetWidth / 2;
            const greenCanvasCenterY = leftSidebar.offsetHeight / 2;
            const initialLeft = greenCanvasCenterX - (100 / 2);
            const initialTop = greenCanvasCenterY - (50 / 2);

            wrapperDiv.style.left = `${initialLeft}px`;
            wrapperDiv.style.top = `${initialTop}px`;
            wrapperDiv.style.minWidth = '50px';
            wrapperDiv.style.minHeight = '30px';
            wrapperDiv.style.zIndex = getNextHighestZIndex();
            applyElementTransform(wrapperDiv, 0, 1);
            wrapperDiv.style.opacity = '0';
            wrapperDiv.style.width = 'auto';
            wrapperDiv.style.height = 'auto';
            wrapperDiv.dataset.originalName = 'Text Element';
            wrapperDiv.dataset.readyForInteraction = 'false';
            wrapperDiv.style.pointerEvents = 'none';
            const readyTime = Date.now() + ELEMENT_VISIBILITY_DELAY_MS;
            wrapperDiv.dataset.readyTimestamp = readyTime;


            const textDiv = document.createElement('div');
            textDiv.classList.add('element-content', 'text-content', 'text-lg');
            textDiv.contentEditable = true;
            textDiv.textContent = textContent;
            textDiv.spellcheck = false;

            textDiv.style.color = textColorInput.value;
            textDiv.style.webkitTextFillColor = textColorInput.value;
            textDiv.style.fontSize = `${fontSizeRange.value}px`;

            if (toggleTextBg.checked) {
                textDiv.style.backgroundColor = textBgColorInput.value;
            } else {
                textDiv.style.backgroundColor = 'transparent';
            }

            if (toggleTextOutline.checked) {
                const thickness = outlineThicknessRange.value;
                const color = textOutlineColorInput.value;
                textDiv.style.webkitTextStrokeWidth = `${thickness}px`;
                textDiv.style.webkitTextStrokeColor = color;
                textDiv.style.textShadow = generateTextShadowForOutline(thickness, color);
            } else {
                textDiv.style.webkitTextStrokeWidth = '0';
                textDiv.style.webkitTextStrokeColor = 'transparent';
                textDiv.style.textShadow = 'none';
            }

            if (boldTextBtn.classList.contains('active-style')) {
                textDiv.classList.add('font-bold');
            }
            if (italicTextBtn.classList.contains('active-style')) {
                textDiv.classList.add('italic');
            }

            wrapperDiv.appendChild(textDiv);
            addHandles(wrapperDiv);
            mainCanvasWrapper.appendChild(wrapperDiv); 
            allElements.set(wrapperDiv.id, wrapperDiv);
            adjustTextElementWrapperSize(wrapperDiv);

            updateLayersList();
            updateFileCountDisplay();
            
            const elementState = {
                id: wrapperDiv.id,
                left: wrapperDiv.style.left,
                top: wrapperDiv.style.top,
                width: wrapperDiv.style.width,
                height: wrapperDiv.style.height,
                rotation: 0,
                scale: 1,
                zIndex: wrapperDiv.style.zIndex,
                opacity: '1',
                originalName: wrapperDiv.dataset.originalName,
                type: 'text',
                textContent: textDiv.textContent,
                color: textDiv.style.color,
                backgroundColor: textDiv.style.backgroundColor,
                fontSize: textDiv.style.fontSize,
                isBold: textDiv.classList.contains('font-bold'),
                isItalic: textDiv.classList.contains('italic'),
                outlineThickness: textDiv.style.webkitTextStrokeWidth,
                outlineColor: textDiv.style.webkitTextStrokeColor,
                hasTextBackground: (textDiv.style.backgroundColor !== 'transparent'),
                hasTextOutline: (parseFloat(textDiv.style.webkitTextStrokeWidth) > 0),
                readyForInteraction: 'false',
                readyTimestamp: readyTime
            };
            sendWebSocketMessage('elementAdd', { element: elementState });

            setTimeout(() => {
                wrapperDiv.style.opacity = '1';
                wrapperDiv.style.pointerEvents = 'auto';
                wrapperDiv.dataset.readyForInteraction = 'true';
                updateLayersList();
            }, ELEMENT_VISIBILITY_DELAY_MS);

        });

        textInput.addEventListener('input', () => {
            if (selectedElementWrapper && selectedElementWrapper.dataset.readyForInteraction === 'true') { 
                const isReady = selectedElementWrapper.dataset.readyForInteraction === 'true';
                if (!isReady) {
                    return;
                }

                const contentElement = selectedElementWrapper.querySelector('.element-content');
                if (contentElement && contentElement.classList.contains('text-content')) {
                    contentElement.textContent = textInput.value;
                    adjustTextElementWrapperSize(selectedElementWrapper);
                    updateLayersList();

                    if (!dragSendTimeout) { 
                        dragSendTimeout = setTimeout(() => {
                            sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                            dragSendTimeout = null;
                        }, DRAG_SEND_THROTTLE_MS);
                    }
                }
            }
        });

        function getElementState(element) {
            if (!element) {
                return null;
            }

            if (element.tagName === 'AUDIO') {
                return {
                    id: element.id,
                    type: 'audio',
                    src: element.src,
                    volume: element.volume,
                    currentTime: element.currentTime, 
                    paused: element.paused,
                    isPlaying: !element.paused, 
                    duration: element.duration,
                    lastVolume: element.dataset.lastVolume,
                    originalName: element.dataset.originalName,
                    publicId: element.dataset.publicId,
                    readyTimestamp: parseFloat(element.dataset.readyTimestamp || Date.now()), 
                    left: '0px', top: '0px', width: '0px', height: '0px',
                    rotation: 0, scale: 1, zIndex: 0, opacity: 1,
                    visibility: 'hidden',
                    readyForInteraction: element.dataset.readyForInteraction || 'true',
                    isLocalUpload: element.dataset.isLocalUpload === 'true' ? true : false
                };
            } else if (element.classList && element.classList.contains('element-wrapper')) {
                const contentElement = element.querySelector('img.element-content, div.text-content.element-content');
                if (!contentElement) {
                    return null;
                }

                const state = {
                    id: element.id,
                    left: element.style.left, 
                    top: element.style.top,   
                    width: element.style.width,
                    height: element.style.height,
                    zIndex: element.style.zIndex,
                    opacity: element.style.opacity,
                    originalName: element.dataset.originalName || '',
                    readyForInteraction: element.dataset.readyForInteraction || 'true',
                    readyTimestamp: parseFloat(element.dataset.readyTimestamp || Date.now())
                };

                const transform = element.style.transform;
                let currentRotation = 0;
                let currentScale = 1;

                const rotationMatch = transform.match(/rotate\(([-?\d.]+)deg\)/);
                if (rotationMatch) {
                    currentRotation = parseFloat(rotationMatch[1]);
                }

                const scaleMatch = transform.match(/scale\(([-?\d.]+)\)/);
                if (scaleMatch) {
                    currentScale = parseFloat(scaleMatch[1]);
                }

                state.rotation = currentRotation;
                state.scale = currentScale;

                if (contentElement.tagName === 'IMG') {
                    state.type = 'img';
                    state.src = contentElement.src;
                    state.initialAspectRatio = element.dataset.initialAspectRatio;
                    state.publicId = element.dataset.publicId;
                } else if (contentElement.classList.contains('text-content')) {
                    state.type = 'text';
                    state.textContent = contentElement.textContent;
                    state.color = contentElement.style.color;
                    state.backgroundColor = contentElement.style.backgroundColor;
                    state.fontSize = contentElement.style.fontSize;
                    state.isBold = contentElement.classList.contains('font-bold');
                    state.isItalic = contentElement.classList.contains('italic');
                    state.outlineThickness = contentElement.style.webkitTextStrokeWidth;
                    state.outlineColor = contentElement.style.webkitTextStrokeColor;
                    state.hasTextBackground = (contentElement.style.backgroundColor !== 'transparent'); 
                    state.hasTextOutline = (parseFloat(contentElement.style.webkitTextStrokeWidth) > 0); 
                }
                return state;
            }
            return null;
        }

        opacityRange.addEventListener('input', () => {
            if (selectedElementWrapper && selectedElementWrapper.dataset.readyForInteraction === 'true') { 
                selectedElementWrapper.style.opacity = opacityRange.value;
                opacityValue.textContent = `${Math.round(opacityRange.value * 100)}%`;
                if (!dragSendTimeout) {
                    dragSendTimeout = setTimeout(() => {
                        sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                        dragSendTimeout = null;
                    }, DRAG_SEND_THROTTLE_MS);
                }
            }
        });

        rotationRange.addEventListener('input', () => {
            if (selectedElementWrapper && selectedElementWrapper.dataset.readyForInteraction === 'true') { 
                const currentScale = getElementState(selectedElementWrapper).scale;
                const newRotation = parseFloat(rotationRange.value);
                applyElementTransform(selectedElementWrapper, newRotation, currentScale);
                rotationValue.textContent = `${Math.round(newRotation)}°`;
                if (!dragSendTimeout) {
                    dragSendTimeout = setTimeout(() => {
                        sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                        dragSendTimeout = null;
                    }, DRAG_SEND_THROTTLE_MS);
                }
            }
        });

        sizeRange.addEventListener('input', () => {
            if (selectedElementWrapper && selectedElementWrapper.dataset.readyForInteraction === 'true') { 
                const currentRotation = getElementState(selectedElementWrapper).rotation;
                const newScale = parseFloat(sizeRange.value);
                applyElementTransform(selectedElementWrapper, currentRotation, newScale);
                sizeValue.textContent = `${Math.round(newScale * 100)}%`;
                if (!dragSendTimeout) {
                    dragSendTimeout = setTimeout(() => {
                        sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                        dragSendTimeout = null;
                        }, DRAG_SEND_THROTTLE_MS);
                    }
                }
        });

        duplicateElementBtn.addEventListener('click', () => {
            if (allElements.size >= fileLimit) {
                return;
            }
            if (selectedElementWrapper && selectedElementWrapper.dataset.readyForInteraction === 'true') { 
                if (selectedElementWrapper.tagName === 'AUDIO') {
                    return;
                }

                const originalState = getElementState(selectedElementWrapper);
                if (!originalState) return;

                const newId = generateUniqueId();
                const readyTime = Date.now() + ELEMENT_VISIBILITY_DELAY_MS;

                const clonedWrapper = selectedElementWrapper.cloneNode(true);
                clonedWrapper.id = newId;
                clonedWrapper.style.left = `${parseFloat(selectedElementWrapper.style.left) + 20}px`;
                clonedWrapper.style.top = `${parseFloat(selectedElementWrapper.style.top) + 20}px`;
                clonedWrapper.style.zIndex = getNextHighestZIndex();
                
                clonedWrapper.querySelectorAll('.resize-handle').forEach(handle => handle.style.display = 'none');
                const cloneRotationHandle = clonedWrapper.querySelector('.rotation-handle');
                if (cloneRotationHandle) cloneRotationHandle.style.display = 'none';
                
                clonedWrapper.classList.remove('selected');

                const clonedContentElement = clonedWrapper.querySelector('.element-content');
                if (clonedContentElement && clonedContentElement.classList.contains('text-content')) {
                    clonedContentElement.contentEditable = true;
                    adjustTextElementWrapperSize(clonedWrapper);
                }

                if (clonedWrapper.dataset.initialAspectRatio === undefined && originalState.initialAspectRatio) {
                    clonedWrapper.dataset.initialAspectRatio = originalState.initialAspectRatio;
                }
                if (clonedWrapper.dataset.publicId === undefined && originalState.publicId) {
                    clonedWrapper.dataset.publicId = originalState.publicId;
                }

                clonedWrapper.dataset.readyForInteraction = 'false';
                clonedWrapper.style.opacity = '0';
                clonedWrapper.style.pointerEvents = 'none';
                clonedWrapper.dataset.readyTimestamp = readyTime;


                mainCanvasWrapper.appendChild(clonedWrapper); 
                allElements.set(newId, clonedWrapper);

                updateLayersList();
                updateFileCountDisplay();
                
                const clonedState = getElementState(clonedWrapper);
                clonedState.readyForInteraction = 'false';
                clonedState.readyTimestamp = readyTime;
                clonedState.opacity = '1';

                sendWebSocketMessage('elementAdd', { element: clonedState });

                setTimeout(() => {
                    clonedWrapper.style.opacity = '1';
                    clonedWrapper.style.pointerEvents = 'auto';
                    clonedWrapper.dataset.readyForInteraction = 'true';
                    updateLayersList();
                }, ELEMENT_VISIBILITY_DELAY_MS);
            }
        });

        deleteElementBtn.addEventListener('click', () => {
            if (selectedElementWrapper && selectedElementWrapper.dataset.readyForInteraction === 'true') { 
                const deletedId = selectedElementWrapper.id;
                deleteElementFromData(deletedId);
                sendWebSocketMessage('elementDelete', { elementId: deletedId });
            } else {
            }
        });

        textColorInput.addEventListener('input', () => {
            if (selectedElementWrapper && selectedElementWrapper.dataset.readyForInteraction === 'true') { 
                const contentElement = selectedElementWrapper.querySelector('.element-content');
                if (contentElement && contentElement.classList.contains('text-content')) {
                    contentElement.style.color = textColorInput.value;
                    contentElement.style.webkitTextFillColor = textColorInput.value;
                    if (toggleTextOutline.checked) {
                        contentElement.style.textShadow = generateTextShadowForOutline(outlineThicknessRange.value, textOutlineColorInput.value);
                    }
                    adjustTextElementWrapperSize(selectedElementWrapper);
                    if (!dragSendTimeout) {
                        dragSendTimeout = setTimeout(() => {
                            sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                            dragSendTimeout = null;
                        }, DRAG_SEND_THROTTLE_MS);
                    }
                }
            }
        });

        textBgColorInput.addEventListener('input', () => {
            if (selectedElementWrapper && selectedElementWrapper.dataset.readyForInteraction === 'true') { 
                const contentElement = selectedElementWrapper.querySelector('.element-content');
                if (contentElement && contentElement.classList.contains('text-content')) {
                    contentElement.style.backgroundColor = textBgColorInput.value;
                    if (!dragSendTimeout) {
                        dragSendTimeout = setTimeout(() => {
                            sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                            dragSendTimeout = null;
                        }, DRAG_SEND_THROTTLE_MS);
                    }
                }
            }
        });

        boldTextBtn.addEventListener('click', () => {
            if (selectedElementWrapper && selectedElementWrapper.dataset.readyForInteraction === 'true') { 
                const contentElement = selectedElementWrapper.querySelector('.element-content');
                if (contentElement && contentElement.classList.contains('text-content')) {
                    contentElement.classList.toggle('font-bold');
                    adjustTextElementWrapperSize(selectedElementWrapper);
                    sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                }
            }
            boldTextBtn.classList.toggle('active-style');
        });

        italicTextBtn.addEventListener('click', () => {
            if (selectedElementWrapper && selectedElementWrapper.dataset.readyForInteraction === 'true') { 
                const contentElement = selectedElementWrapper.querySelector('.element-content');
                if (contentElement && contentElement.classList.contains('text-content')) {
                    contentElement.classList.toggle('italic');
                    adjustTextElementWrapperSize(selectedElementWrapper);
                    sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                }
            }
            italicTextBtn.classList.toggle('active-style');
        });

        toggleTextBg.addEventListener('change', () => {
            if (selectedElementWrapper && selectedElementWrapper.dataset.readyForInteraction === 'true') { 
                const textElement = selectedElementWrapper.querySelector('.element-content');
                if (textElement && textElement.classList.contains('text-content')) {
                    if (toggleTextBg.checked) {
                        textElement.style.backgroundColor = textBgColorInput.value;
                        textBgColorInput.disabled = false;
                        textBgColorLabel.classList.remove('text-gray-600');
                        textBgColorLabel.classList.add('text-gray-300');
                    } else {
                        textElement.style.backgroundColor = 'transparent';
                        textBgColorInput.disabled = true;
                        textBgColorLabel.classList.add('text-gray-600');
                        textBgColorLabel.classList.remove('text-gray-300');
                    }
                    sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                }
            } else {
                 textBgColorInput.disabled = !toggleTextBg.checked;
                 textBgColorLabel.classList.toggle('text-gray-600', !toggleTextBg.checked);
                 textBgColorLabel.classList.toggle('text-gray-300', toggleTextBg.checked);
            }
        });

        toggleTextOutline.addEventListener('change', () => {
            if (selectedElementWrapper && selectedElementWrapper.dataset.readyForInteraction === 'true') { 
                const textElement = selectedElementWrapper.querySelector('.element-content');
                if (textElement && textElement.classList.contains('text-content')) {
                    if (toggleTextOutline.checked) {
                        const thickness = outlineThicknessRange.value;
                        const color = textOutlineColorInput.value;
                        textElement.style.webkitTextStrokeWidth = `${thickness}px`;
                        textElement.style.webkitTextStrokeColor = color;
                        textElement.style.textShadow = generateTextShadowForOutline(thickness, color);
                        textOutlineColorInput.disabled = false;
                        outlineThicknessRange.disabled = false;
                        textOutlineColorLabel.classList.remove('text-gray-600');
                        textOutlineColorLabel.classList.add('text-gray-300');
                        outlineThicknessLabel.classList.remove('text-gray-600');
                        outlineThicknessLabel.classList.add('text-gray-300');
                    } else {
                        textElement.style.webkitTextStrokeWidth = '0';
                        textElement.style.webkitTextStrokeColor = 'transparent';
                        textElement.style.textShadow = 'none';
                        textOutlineColorInput.disabled = true;
                        outlineThicknessRange.disabled = true;
                        textOutlineColorLabel.classList.add('text-gray-600');
                        textOutlineColorLabel.classList.remove('text-gray-300');
                        outlineThicknessLabel.classList.add('text-gray-600');
                        outlineThicknessLabel.classList.remove('text-gray-300');
                    }
                    adjustTextElementWrapperSize(selectedElementWrapper);
                    sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                }
            } else {
                textOutlineColorInput.disabled = !toggleTextOutline.checked;
                outlineThicknessRange.disabled = !toggleTextOutline.checked;
                textOutlineColorLabel.classList.toggle('text-gray-600', !toggleTextOutline.checked);
                textOutlineColorLabel.classList.toggle('text-gray-300', toggleTextOutline.checked);
                outlineThicknessLabel.classList.toggle('text-gray-600', !toggleTextOutline.checked);
                outlineThicknessLabel.classList.toggle('text-gray-300', toggleTextOutline.checked);
            }
        });

        textOutlineColorInput.addEventListener('input', () => {
            if (selectedElementWrapper && selectedElementWrapper.dataset.readyForInteraction === 'true') { 
                const contentElement = selectedElementWrapper.querySelector('.element-content');
                if (contentElement && contentElement.classList.contains('text-content') && toggleTextOutline.checked) {
                    contentElement.style.webkitTextStrokeColor = textOutlineColorInput.value;
                    contentElement.style.textShadow = generateTextShadowForOutline(outlineThicknessRange.value, textOutlineColorInput.value);
                    adjustTextElementWrapperSize(selectedElementWrapper);
                    if (!dragSendTimeout) {
                        dragSendTimeout = setTimeout(() => {
                            sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                            dragSendTimeout = null;
                        }, DRAG_SEND_THROTTLE_MS);
                    }
                }
            }
        });

        outlineThicknessRange.addEventListener('input', () => {
            if (selectedElementWrapper && selectedElementWrapper.dataset.readyForInteraction === 'true') { 
                const contentElement = selectedElementWrapper.querySelector('.element-content');
                if (contentElement && contentElement.classList.contains('text-content') && toggleTextOutline.checked) {
                    const thickness = outlineThicknessRange.value;
                    const color = textOutlineColorInput.value;
                    contentElement.style.webkitTextStrokeWidth = `${thickness}px`;
                    contentElement.style.webkitTextStrokeColor = color;
                    contentElement.style.textShadow = generateTextShadowForOutline(thickness, color);
                    outlineThicknessValue.textContent = `${thickness}px`;
                    adjustTextElementWrapperSize(selectedElementWrapper);
                    if (!dragSendTimeout) {
                        dragSendTimeout = setTimeout(() => {
                            sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                            dragSendTimeout = null;
                        }, DRAG_SEND_THROTTLE_MS);
                    }
                }
            } else {
                outlineThicknessValue.textContent = `${outlineThicknessRange.value}px`;
            }
        });

        fontSizeRange.addEventListener('input', () => {
            if (selectedElementWrapper && selectedElementWrapper.dataset.readyForInteraction === 'true') { 
                const contentElement = selectedElementWrapper.querySelector('.element-content');
                if (contentElement && contentElement.classList.contains('text-content')) {
                    contentElement.style.fontSize = `${fontSizeRange.value}px`;
                    adjustTextElementWrapperSize(selectedElementWrapper);
                    if (!dragSendTimeout) {
                        dragSendTimeout = setTimeout(() => {
                            sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                            dragSendTimeout = null;
                        }, DRAG_SEND_THROTTLE_MS);
                    }
                }
            }
            fontSizeValue.textContent = `${fontSizeRange.value}px`;
        });

        resetOpacityBtn.addEventListener('click', () => {
            if (selectedElementWrapper && selectedElementWrapper.dataset.readyForInteraction === 'true') { 
                selectedElementWrapper.style.opacity = '1';
                opacityRange.value = 1;
                opacityValue.textContent = '100%';
                sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
            }
        });

        resetRotationBtn.addEventListener('click', () => {
            if (selectedElementWrapper && selectedElementWrapper.dataset.readyForInteraction === 'true') { 
                const currentScale = getElementState(selectedElementWrapper).scale;
                applyElementTransform(selectedElementWrapper, 0, currentScale);
                rotationRange.value = 0;
                rotationValue.textContent = '0°';
                sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
            }
        });

        resetSizeBtn.addEventListener('click', () => {
            if (selectedElementWrapper && selectedElementWrapper.dataset.readyForInteraction === 'true') { 
                const currentRotation = getElementState(selectedElementWrapper).rotation;
                applyElementTransform(selectedElementWrapper, currentRotation, 1);
                sizeRange.value = 1;
                sizeValue.textContent = '100%';
                sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
            }
        });


        playPauseBtn.addEventListener('click', () => {
            if (selectedAudioElement) {
                const isReady = (selectedAudioElement.dataset.readyForInteraction === 'true');
                const readyTime = parseFloat(selectedAudioElement.dataset.readyTimestamp || 0);
                const currentTime = Date.now();
                const rawTimeDiff = readyTime - currentTime; 
                const timeRemainingSeconds = Math.max(0, Math.ceil(rawTimeDiff / 1000));


                if (!isReady && rawTimeDiff > 0) {
                    showConfirmationModal(`Este audio estará disponible para reproducir en ${timeRemainingSeconds} segundos.`, null);
                    return;
                } 
                else if (!isReady && rawTimeDiff <= 0) {
                    selectedAudioElement.dataset.readyForInteraction = 'true';
                    const updatedState = getElementState(selectedAudioElement);
                    updatedState.readyForInteraction = 'true';
                    sendWebSocketMessage('elementUpdate', { element: updatedState });
                }

                const wasPaused = selectedAudioElement.paused;
                const targetIsPlaying = wasPaused;

                if (targetIsPlaying) {
                    allElements.forEach(element => {
                        if (element.tagName === 'AUDIO' && element !== selectedAudioElement && !element.paused) {
                            element.pause();
                            sendWebSocketMessage('elementUpdate', {
                                element: {
                                    ...getElementState(element),
                                    isPlaying: false,
                                    paused: true 
                                }
                            });
                        }
                    });

                    selectedAudioElement.play().catch(e => {
                        updatePlayPauseButton(true);
                        return; 
                    });
                } else {
                    selectedAudioElement.pause();
                }

                updatePlayPauseButton(!targetIsPlaying);
                
                const stateToSend = getElementState(selectedAudioElement);
                stateToSend.isPlaying = targetIsPlaying;
                stateToSend.paused = !targetIsPlaying;
                stateToSend.currentTime = selectedAudioElement.currentTime; 

                sendWebSocketMessage('elementUpdate', { element: stateToSend });
            }
        });

        volumeRange.addEventListener('input', () => {
            if (selectedAudioElement) {
                const newVolume = parseFloat(volumeRange.value);
                selectedAudioElement.volume = newVolume;
                selectedAudioElement.dataset.lastVolume = newVolume;
                
                if (newVolume === 0) {
                    selectedAudioElement.muted = true;
                } else {
                    selectedAudioElement.muted = isMutedGlobally; 
                }
                volumeValueDisplay.textContent = `${Math.round(newVolume * 100)}%`;
                sendWebSocketMessage('elementUpdate', { element: getElementState(selectedAudioElement) });
            }
        });

        let isDraggingTimeline = false;
        timelineRange.addEventListener('mousedown', () => {
            isDraggingTimeline = true;
        });

        timelineRange.addEventListener('mouseup', () => {
            isDraggingTimeline = false;
            if (selectedAudioElement) {
                selectedAudioElement.currentTime = parseFloat(timelineRange.value);
                sendWebSocketMessage('elementUpdate', { element: getElementState(selectedAudioElement) });
            }
        });

        timelineRange.addEventListener('input', () => {
            if (selectedAudioElement) {
                currentTimeDisplay.textContent = `${formatTime(parseFloat(timelineRange.value))} / ${formatTime(selectedAudioElement.duration)}`;
            }
        });


        bringToFrontBtn.addEventListener('click', () => {
            if (selectedElementWrapper && selectedElementWrapper.dataset.readyForInteraction === 'true') { 
                selectedElementWrapper.style.zIndex = getNextHighestZIndex();
                updateLayersList();
                selectElement(selectedElementWrapper);
                sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                const updatedElementsForReorder = Array.from(allElements.values())
                                                    .filter(el => el.classList && el.classList.contains('element-wrapper'))
                                                    .map(el => ({ id: el.id, zIndex: el.style.zIndex }));
                sendWebSocketMessage('reorderLayers', { elements: updatedElementsForReorder });
            }
        });

        document.addEventListener('mousedown', (e) => {
            const target = e.target;
            const clickedWrapper = target.closest('.element-wrapper');
            const clickedAudioListItem = target.closest('.audio-list-item');

            const wrapperRect = mainCanvasWrapper.getBoundingClientRect();
            const mouseXOnUnscaledWrapper = (e.clientX - wrapperRect.left) / currentZoom;
            const mouseYOnUnscaledWrapper = (e.clientY - wrapperRect.top) / currentZoom;

            if (clickedWrapper) {
                if (clickedWrapper.dataset.readyForInteraction !== 'true') {
                    showConfirmationModal('El elemento aún no está listo para interactuar. Espera un momento.', null);
                    return; 
                }
                e.stopPropagation();

                if (target.classList.contains('resize-handle')) {
                    e.preventDefault();
                    isResizing = true;
                    selectElement(clickedWrapper);
                    activeHandle = Array.from(target.classList).find(cls => cls.startsWith('top-') || cls.startsWith('bottom-'));
                    initialMouseX = mouseXOnUnscaledWrapper;
                    initialMouseY = mouseYOnUnscaledWrapper;
                    initialLeft = selectedElementWrapper.offsetLeft;
                    initialTop = selectedElementWrapper.offsetTop;
                    initialWidth = selectedElementWrapper.offsetWidth;
                    initialHeight = selectedElementWrapper.offsetHeight;
                    return;
                }

                if (target.classList.contains('rotation-handle')) {
                    e.preventDefault();
                    isRotating = true;
                    selectElement(clickedWrapper);
                    const rect = selectedElementWrapper.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    initialRotationAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                    initialElementRotation = getElementState(selectedElementWrapper).rotation;
                    return;
                }

                e.preventDefault();
                isDragging = true;
                selectElement(clickedWrapper);
                initialMouseX = mouseXOnUnscaledWrapper;
                initialMouseY = mouseYOnUnscaledWrapper;
                initialLeft = clickedWrapper.offsetLeft;
                initialTop = clickedWrapper.offsetTop;
            } else if (clickedAudioListItem) {
                 e.stopPropagation();
            }
            else {
                if (!target.closest('aside') && !target.closest('.zoom-controls') && !target.closest('.modal-overlay')) {
                    deselectAllElements();
                }
            }
        });

        document.addEventListener('mousemove', (e) => {
            const wrapperRect = mainCanvasWrapper.getBoundingClientRect();
            const currentMouseXOnUnscaledWrapper = (e.clientX - wrapperRect.left) / currentZoom;
            const currentMouseYOnUnscaledWrapper = (e.clientY - wrapperRect.top) / currentZoom;

            if ((isDragging || isResizing || isRotating) && selectedElementWrapper && selectedElementWrapper.dataset.readyForInteraction === 'true') { 
                e.preventDefault();

                if (!pendingDOMUpdateAnimationFrame) {
                    pendingDOMUpdateAnimationFrame = requestAnimationFrame(() => {
                        if (isDragging) {
                            const dx = currentMouseXOnUnscaledWrapper - initialMouseX;
                            const dy = currentMouseYOnUnscaledWrapper - initialMouseY;
                            selectedElementWrapper.style.left = `${initialLeft + dx}px`;
                            selectedElementWrapper.style.top = `${initialTop + dy}px`;
                        } else if (isResizing) {
                            const dx = currentMouseXOnUnscaledWrapper - initialMouseX;
                            const dy = currentMouseYOnUnscaledWrapper - initialMouseY;

                            let newWidth = initialWidth;
                            let newHeight = initialHeight;
                            let newLeft = initialLeft;
                            let newTop = initialTop;

                            const contentElement = selectedElementWrapper.querySelector('.element-content');
                            if (contentElement && (contentElement.tagName === 'IMG')) {
                                const originalImageAspectRatio = parseFloat(selectedElementWrapper.dataset.initialAspectRatio);

                                let potentialNewWidth = initialWidth + (activeHandle.includes('left') ? -dx : dx);
                                let potentialNewHeight = initialHeight + (activeHandle.includes('top') ? -dy : dy);

                                if (Math.abs(potentialNewWidth - initialWidth) > Math.abs(potentialNewHeight - initialHeight)) {
                                    newWidth = potentialNewWidth;
                                    newHeight = newWidth / originalImageAspectRatio;
                                } else {
                                    newHeight = potentialNewHeight;
                                    newWidth = newHeight * originalImageAspectRatio;
                                }

                                newWidth = Math.max(20, newWidth);
                                newHeight = Math.max(20, newHeight);

                                if (activeHandle.includes('left')) {
                                    newLeft = initialLeft + initialWidth - newWidth;
                                }
                                if (activeHandle.includes('top')) {
                                    newTop = initialTop + initialHeight - newHeight;
                                }

                            } else if (contentElement && contentElement.classList.contains('text-content')) {
                                switch (activeHandle) {
                                    case 'top-left':
                                        newWidth = initialWidth - dx;
                                        newHeight = initialHeight - dy;
                                        newLeft = initialLeft + dx;
                                        newTop = initialTop + dy;
                                        break;
                                    case 'top-right':
                                        newWidth = initialWidth + dx;
                                        newHeight = initialHeight - dy;
                                        newTop = initialTop + dy;
                                        break;
                                    case 'bottom-left':
                                        newWidth = initialWidth - dx;
                                        newHeight = initialHeight + dy;
                                        newLeft = initialLeft + dx;
                                        break;
                                    case 'bottom-right':
                                        newWidth = initialWidth + dx;
                                        newHeight = initialHeight + dy;
                                        break;
                                }

                                const textElement = contentElement;
                                const tempDiv = document.createElement('div');
                                tempDiv.style.position = 'absolute';
                                tempDiv.style.visibility = 'hidden';
                                tempDiv.style.whiteSpace = 'pre-wrap';
                                tempDiv.style.wordBreak = 'break-word';
                                tempDiv.style.boxSizing = 'border-box';
                                tempDiv.style.fontSize = window.getComputedStyle(textElement).fontSize;
                                tempDiv.style.fontWeight = window.getComputedStyle(textElement).fontWeight;
                                tempDiv.style.fontStyle = window.getComputedStyle(textElement).fontStyle;
                                tempDiv.style.fontFamily = window.getComputedStyle(textElement).fontFamily;
                                tempDiv.style.lineHeight = '1';
                                tempDiv.style.textAlign = 'center';
                                tempDiv.style.display = 'flex';
                                tempDiv.style.alignItems = 'center';
                                tempDiv.style.justifyContent = 'center';

                                const outlineThickness = parseFloat(textElement.style.webkitTextStrokeWidth) || 0;
                                const outlineColor = textElement.style.webkitTextStrokeColor || '#000000';
                                if (outlineThickness > 0) {
                                    tempDiv.style.webkitTextStrokeWidth = `${outlineThickness}px`;
                                    tempDiv.style.webkitTextStrokeColor = outlineColor;
                                    tempDiv.style.textShadow = generateTextShadowForOutline(outlineThickness, outlineColor);
                                    } else {
                                    tempDiv.style.webkitTextStrokeWidth = '0';
                                    tempDiv.style.webkitTextStrokeColor = 'transparent';
                                    tempDiv.style.textShadow = 'none';
                                }

                                tempDiv.textContent = textElement.textContent;
                                document.body.appendChild(tempDiv);

                                const rawTextRect = tempDiv.getBoundingClientRect();
                                const minContentWidth = rawTextRect.width;
                                const minContentHeight = rawTextRect.height;
                                document.body.removeChild(tempDiv);

                                const wrapperPaddingHorizontal = 25;
                                const wrapperPaddingVertical = 10;
                                const clampedWidth = Math.max(newWidth, minContentWidth + (wrapperPaddingHorizontal * 2));
                                const clampedHeight = Math.max(newHeight, minContentHeight + (wrapperPaddingVertical * 2));

                                const widthDiff = clampedWidth - newWidth;
                                const heightDiff = clampedHeight - newHeight;
                                if (activeHandle.startsWith('top-')) {
                                    newTop -= heightDiff;
                                }
                                if (activeHandle.endsWith('-left')) {
                                    newLeft -= widthDiff;
                                }
                                newWidth = clampedWidth;
                                newHeight = clampedHeight;
                            }

                            newWidth = Math.max(20, newWidth);
                            newHeight = Math.max(20, newHeight);

                            selectedElementWrapper.style.width = `${newWidth}px`;
                            selectedElementWrapper.style.height = `${newHeight}px`;
                            selectedElementWrapper.style.left = `${newLeft}px`;
                            selectedElementWrapper.style.top = `${newTop}px`;

                            initialMouseX = currentMouseXOnUnscaledWrapper;
                            initialMouseY = currentMouseYOnUnscaledWrapper;
                            initialWidth = newWidth;
                            initialHeight = newHeight;
                            initialLeft = newLeft;
                            initialTop = newTop;

                        } else if (isRotating) {
                            const rect = selectedElementWrapper.getBoundingClientRect();
                            const centerX = rect.left + rect.width / 2;
                            const centerY = rect.top + rect.height / 2;

                            const currentAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
                            const angleDiff = (currentAngle - initialRotationAngle) * 180 / Math.PI;
                            let newRotation = initialElementRotation + angleDiff;
                            newRotation = (newRotation % 360 + 360) % 360;

                            const currentScale = getElementState(selectedElementWrapper).scale;
                            applyElementTransform(selectedElementWrapper, newRotation, currentScale);
                            rotationRange.value = newRotation;
                            rotationValue.textContent = `${Math.round(newRotation)}°`;

                            initialRotationAngle = currentAngle;
                            initialElementRotation = newRotation;
                        }
                        pendingDOMUpdateAnimationFrame = null; 
                    });
                }

                if (!dragSendTimeout) {
                    dragSendTimeout = setTimeout(() => {
                        if (selectedElementWrapper) {
                            sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                        }
                        dragSendTimeout = null;
                    }, DRAG_SEND_THROTTLE_MS);
                }
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDragging || isResizing || isRotating) {
                if (pendingDOMUpdateAnimationFrame) {
                    cancelAnimationFrame(pendingDOMUpdateAnimationFrame);
                    pendingDOMUpdateAnimationFrame = null;
                }
                if (dragSendTimeout) {
                    clearTimeout(dragSendTimeout);
                    dragSendTimeout = null;
                }
                if (selectedElementWrapper && selectedElementWrapper.dataset.readyForInteraction === 'true') { 
                    sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                }
            }
            isDragging = false;
            isResizing = false;
            isRotating = false;
            activeHandle = '';
        });

        document.addEventListener('touchstart', (e) => {
            const target = e.target;
            const clickedWrapper = target.closest('.element-wrapper');
            const clickedAudioListItem = target.closest('.audio-list-item');

            const wrapperRect = mainCanvasWrapper.getBoundingClientRect();
            const touchXOnUnscaledWrapper = (e.touches[0].clientX - wrapperRect.left) / currentZoom;
            const touchYOnUnscaledWrapper = (e.touches[0].clientY - wrapperRect.top) / currentZoom;

            if (e.touches.length === 1) {
                if (target === timelineRange) {
                    isDraggingTimeline = true;
                    return;
                }

                if (clickedWrapper) {
                    if (clickedWrapper.dataset.readyForInteraction !== 'true') {
                        showConfirmationModal('El elemento aún no está listo para interactuar. Espera un momento.', null);
                        return;
                    }
                    if (target.classList.contains('resize-handle')) {
                        e.preventDefault();
                        isResizing = true;
                        selectElement(clickedWrapper);
                        activeHandle = Array.from(target.classList).find(cls => cls.startsWith('top-') || cls.startsWith('bottom-'));
                        initialMouseX = touchXOnUnscaledWrapper;
                        initialMouseY = touchYOnUnscaledWrapper;
                        initialLeft = selectedElementWrapper.offsetLeft;
                        initialTop = selectedElementWrapper.offsetTop;
                        initialWidth = selectedElementWrapper.offsetWidth;
                        initialHeight = selectedElementWrapper.offsetHeight;
                        return;
                    }

                    if (target.classList.contains('rotation-handle')) {
                        e.preventDefault();
                        isRotating = true;
                        selectElement(clickedWrapper);
                        const rect = selectedElementWrapper.getBoundingClientRect();
                        const centerX = rect.left + rect.width / 2;
                        const centerY = rect.top + rect.height / 2;
                        initialRotationAngle = Math.atan2(e.touches[0].clientY - centerY, e.touches[0].clientX - centerX);
                        initialElementRotation = getElementState(selectedElementWrapper).rotation;
                        return;
                    }

                    e.preventDefault();
                    isDragging = true;
                    selectElement(clickedWrapper);
                    initialMouseX = touchXOnUnscaledWrapper;
                    initialMouseY = touchYOnUnscaledWrapper;
                    initialLeft = clickedWrapper.offsetLeft;
                    initialTop = clickedWrapper.offsetTop;
                } else if (clickedAudioListItem) {
                     e.stopPropagation();
                } else {
                    if (!target.closest('aside') && !target.closest('.zoom-controls') && !target.closest('.modal-overlay')) {
                        deselectAllElements();
                    }
                }
            }
        });

        document.addEventListener('touchmove', (e) => {
            const wrapperRect = mainCanvasWrapper.getBoundingClientRect();
            const currentTouchXOnUnscaledWrapper = (e.touches[0].clientX - wrapperRect.left) / currentZoom;
            const currentTouchYOnUnscaledWrapper = (e.touches[0].clientY - wrapperRect.top) / currentZoom;

            if (e.touches.length === 1) {
                if ((isDragging || isResizing || isRotating) && selectedElementWrapper && selectedElementWrapper.dataset.readyForInteraction === 'true') { 
                    e.preventDefault();

                    if (!pendingDOMUpdateAnimationFrame) {
                        pendingDOMUpdateAnimationFrame = requestAnimationFrame(() => {
                            if (isDragging) {
                                const dx = currentTouchXOnUnscaledWrapper - initialMouseX;
                                const dy = currentTouchYOnUnscaledWrapper - initialMouseY;

                                selectedElementWrapper.style.left = `${initialLeft + dx}px`;
                                selectedElementWrapper.style.top = `${initialTop + dy}px`;
                            } else if (isResizing) {
                                const dx = currentTouchXOnUnscaledWrapper - initialMouseX;
                                const dy = currentTouchYOnUnscaledWrapper - initialMouseY;

                                let newWidth = initialWidth;
                                let newHeight = initialHeight;
                                let newLeft = initialLeft;
                                let newTop = initialTop;

                                const contentElement = selectedElementWrapper.querySelector('.element-content');
                                if (contentElement && (contentElement.tagName === 'IMG')) {
                                    const originalImageAspectRatio = parseFloat(selectedElementWrapper.dataset.initialAspectRatio);

                                    let potentialNewWidth = initialWidth + (activeHandle.includes('left') ? -dx : dx);
                                    let potentialNewHeight = initialHeight + (activeHandle.includes('top') ? -dy : dy);

                                    if (Math.abs(potentialNewWidth - initialWidth) > Math.abs(potentialNewHeight - initialHeight)) {
                                        newWidth = potentialNewWidth;
                                        newHeight = newWidth / originalImageAspectRatio;
                                    } else {
                                        newHeight = potentialNewHeight;
                                        newWidth = newHeight * originalImageAspectRatio;
                                    }

                                    newWidth = Math.max(20, newWidth);
                                    newHeight = Math.max(20, newHeight);

                                    if (activeHandle.includes('left')) {
                                        newLeft = initialLeft + initialWidth - newWidth;
                                    }
                                    if (activeHandle.includes('top')) {
                                        newTop = initialTop + initialHeight - newHeight;
                                    }

                                } else if (contentElement && contentElement.classList.contains('text-content')) {
                                    switch (activeHandle) {
                                        case 'top-left':
                                            newWidth = initialWidth - dx;
                                            newHeight = initialHeight - dy;
                                            newLeft = initialLeft + dx;
                                            newTop = initialTop + dy;
                                            break;
                                        case 'top-right':
                                            newWidth = initialWidth + dx;
                                            newHeight = initialHeight - dy;
                                            newTop = initialTop + dy;
                                            break;
                                        case 'bottom-left':
                                            newWidth = initialWidth - dx;
                                            newHeight = initialHeight + dy;
                                            newLeft = initialLeft + dx;
                                            break;
                                        case 'bottom-right':
                                            newWidth = initialWidth + dx;
                                            newHeight = initialHeight + dy;
                                            break;
                                    }

                                    const textElement = contentElement;
                                    const tempDiv = document.createElement('div');
                                    tempDiv.style.position = 'absolute';
                                    tempDiv.style.visibility = 'hidden';
                                    tempDiv.style.whiteSpace = 'pre-wrap';
                                    tempDiv.style.wordBreak = 'break-word';
                                    tempDiv.style.boxSizing = 'border-box';
                                    tempDiv.style.fontSize = window.getComputedStyle(textElement).fontSize;
                                    tempDiv.style.fontWeight = window.getComputedStyle(textElement).fontWeight;
                                    tempDiv.style.fontStyle = window.getComputedStyle(textElement).fontStyle;
                                    tempDiv.style.fontFamily = window.getComputedStyle(textElement).fontFamily;
                                    tempDiv.style.lineHeight = '1';
                                    tempDiv.style.textAlign = 'center';
                                    tempDiv.style.display = 'flex';
                                    tempDiv.style.alignItems = 'center';
                                    tempDiv.style.justifyContent = 'center';

                                    const outlineThickness = parseFloat(textElement.style.webkitTextStrokeWidth) || 0;
                                    const outlineColor = textElement.style.webkitTextStrokeColor || '#000000';
                                    if (outlineThickness > 0) {
                                        tempDiv.style.webkitTextStrokeWidth = `${outlineThickness}px`;
                                        tempDiv.style.webkitTextStrokeColor = outlineColor;
                                        tempDiv.style.textShadow = generateTextShadowForOutline(outlineThickness, outlineColor);
                                    } else {
                                        tempDiv.style.webkitTextStrokeWidth = '0';
                                        tempDiv.style.webkitTextStrokeColor = 'transparent';
                                        tempDiv.style.textShadow = 'none';
                                    }

                                    tempDiv.textContent = textElement.textContent;
                                    document.body.appendChild(tempDiv);
                                    const rawTextRect = tempDiv.getBoundingClientRect();
                                    const minContentWidth = rawTextRect.width;
                                    const minContentHeight = rawTextRect.height;
                                    document.body.removeChild(tempDiv);

                                    const wrapperPaddingHorizontal = 25;
                                    const wrapperPaddingVertical = 10;
                                    const clampedWidth = Math.max(newWidth, minContentWidth + (wrapperPaddingHorizontal * 2));
                                    const clampedHeight = Math.max(newHeight, minContentHeight + (wrapperPaddingVertical * 2));

                                    const widthDiff = clampedWidth - newWidth;
                                    const heightDiff = clampedHeight - newHeight;
                                    if (activeHandle.startsWith('top-')) {
                                        newTop -= heightDiff;
                                    }
                                    if (activeHandle.endsWith('-left')) {
                                        newLeft -= widthDiff;
                                    }
                                    newWidth = clampedWidth;
                                    newHeight = clampedHeight;
                                }

                                newWidth = Math.max(20, newWidth);
                                newHeight = Math.max(20, newHeight);

                                selectedElementWrapper.style.width = `${newWidth}px`;
                                selectedElementWrapper.style.height = `${newHeight}px`;
                                selectedElementWrapper.style.left = `${newLeft}px`;
                                selectedElementWrapper.style.top = `${newTop}px`;

                                initialMouseX = currentTouchXOnUnscaledWrapper;
                                initialMouseY = currentTouchYOnUnscaledWrapper;
                                initialWidth = newWidth;
                                initialHeight = newHeight;
                                initialLeft = newLeft;
                                initialTop = newTop;

                            } else if (isRotating) {
                                const rect = selectedElementWrapper.getBoundingClientRect();
                                const centerX = rect.left + rect.width / 2;
                                const centerY = rect.top + rect.height / 2;

                                const currentAngle = Math.atan2(e.touches[0].clientY - centerY, e.touches[0].clientX - centerX);
                                const angleDiff = (currentAngle - initialRotationAngle) * 180 / Math.PI;
                                let newRotation = initialElementRotation + angleDiff;
                                newRotation = (newRotation % 360 + 360) % 360;

                                const currentScale = getElementState(selectedElementWrapper).scale;
                                applyElementTransform(selectedElementWrapper, newRotation, currentScale);
                                rotationRange.value = newRotation;
                                rotationValue.textContent = `${Math.round(newRotation)}°`;

                                initialRotationAngle = currentAngle;
                                initialElementRotation = newRotation;
                            }
                            pendingDOMUpdateAnimationFrame = null; 
                        });
                    }

                    if (!dragSendTimeout) { 
                        dragSendTimeout = setTimeout(() => {
                            if (selectedElementWrapper) {
                                sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                            }
                            dragSendTimeout = null;
                        }, DRAG_SEND_THROTTLE_MS);
                    }
                }
            }
        });

        document.addEventListener('touchend', () => {
            if (isDragging || isResizing || isRotating || isDraggingTimeline) {
                if (pendingDOMUpdateAnimationFrame) {
                    cancelAnimationFrame(pendingDOMUpdateAnimationFrame);
                    pendingDOMUpdateAnimationFrame = null;
                }
                if (dragSendTimeout) {
                    clearTimeout(dragSendTimeout);
                    dragSendTimeout = null;
                }
                if (selectedElementWrapper && selectedElementWrapper.dataset.readyForInteraction === 'true') { 
                    sendWebSocketMessage('elementUpdate', { element: getElementState(selectedElementWrapper) });
                }
                if (isDraggingTimeline && selectedAudioElement) {
                    selectedAudioElement.currentTime = parseFloat(timelineRange.value);
                    sendWebSocketMessage('elementUpdate', { element: getElementState(selectedAudioElement) });
                }
            }
            isDragging = false;
            isResizing = false;
            isRotating = false;
            isDraggingTimeline = false;
            activeHandle = '';
        });

        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', () => {
                const tabId = button.dataset.tab;
                document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                button.classList.add('active');
                document.getElementById(`tab-content-${tabId}`).classList.add('active');

                if (selectedAudioElement) {
                    deselectAudioControls();
                }

                if (tabId === 'audio') {
                    if (selectedElementWrapper) {
                        deselectAllElements(); 
                    }
                    updateAudioPlaylistDisplay(); 
                } else {
                    if (tabId === 'properties' || tabId === 'text') {
                    }

                    if (tabId === 'properties' && selectedElementWrapper) {
                        if (selectedElementWrapper.dataset.readyForInteraction === 'true') {
                            selectElement(selectedElementWrapper);
                        } else {
                            deselectAllElements();
                        }
                    }
                }
            });
        });

        let draggedLayer = null;
        layersList.addEventListener('dragstart', (e) => {
            const target = e.target.closest('.layer-item');
            if (target) {
                const elementOnCanvas = allElements.get(target.dataset.id);
                if (elementOnCanvas && elementOnCanvas.dataset.readyForInteraction === 'true') {
                    draggedLayer = target;
                    e.dataTransfer.effectAllowed = 'move';
                    setTimeout(() => {
                        target.style.opacity = '0.5';
                    }, 0);
                } else {
                    e.preventDefault();
                }
            }
        });

        layersList.addEventListener('dragover', (e) => {
            e.preventDefault();
            const target = e.target.closest('.layer-item');
            if (target && target !== draggedLayer) {
                const bounding = target.getBoundingClientRect();
                const offset = bounding.y + (bounding.height / 2);
                if (e.clientY < offset) {
                    layersList.insertBefore(draggedLayer, target);
                } else {
                    layersList.insertBefore(draggedLayer, target.nextSibling);
                }
            }
        });

        layersList.addEventListener('dragend', () => {
            if (draggedLayer) {
                draggedLayer.style.opacity = '1';
                draggedLayer = null;

                let maxZ = getNextHighestZIndex() - 1;
                if (maxZ < 100) {
                    maxZ = 100;
                }

                const layersInNewOrder = Array.from(layersList.children);
                const updatedElementsForReorder = [];
                layersInNewOrder.forEach((layerItem, index) => {
                    if (layerItem.dataset.id) {
                        const elementWrapper = allElements.get(layerItem.dataset.id);
                        if (elementWrapper) {
                            const newZIndex = maxZ - index;
                            elementWrapper.style.zIndex = newZIndex;
                            updatedElementsForReorder.push({ id: elementWrapper.id, zIndex: newZIndex });
                        }
                    }
                });

                updateLayersList();
                sendWebSocketMessage('reorderLayers', { elements: updatedElementsForReorder });
            }
        });

        zoomRange.addEventListener('input', () => {
            currentZoom = parseFloat(zoomRange.value);
            applyZoom();
        });

        dropArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropArea.classList.add('highlight');
            e.dataTransfer.dropEffect = 'copy';
        });

        dropArea.addEventListener('dragleave', () => {
            dropArea.classList.remove('highlight');
        });

        dropArea.addEventListener('drop', (e) => {
            e.preventDefault();
            dropArea.classList.remove('highlight');
            if (e.dataTransfer.files.length > 0) {
                handleFile(e.dataTransfer.files[0]);
            }
        });

        let confirmationModalCallback = null;
        const confirmationModal = document.createElement('div');
        confirmationModal.id = 'confirmationModal';
        confirmationModal.classList.add('modal-overlay');
        confirmationModal.innerHTML = `
            <div class="modal-dialog">
                <h3 class="modal-title">Aviso</h3>
                <p class="modal-message" id="confirmationMessage"></p>
                <div class="modal-buttons">
                    <button id="confirmOkBtn" class="modal-button ok">OK</button>
                </div>
            </div>
        `;
        document.body.appendChild(confirmationModal);

        function showConfirmationModal(message, callback) { 
            document.getElementById('confirmationMessage').textContent = message;
            confirmationModal.classList.add('active');

            const oldConfirmOkBtn = document.getElementById('confirmOkBtn');
            const newConfirmOkBtn = oldConfirmOkBtn.cloneNode(true);
            oldConfirmOkBtn.parentNode.replaceChild(newConfirmOkBtn, oldConfirmOkBtn); 

            newConfirmOkBtn.addEventListener('click', () => {
                confirmationModal.classList.remove('active');
                if (callback && typeof callback === 'function') {
                    callback();
                }
            });
        }


        document.addEventListener('DOMContentLoaded', () => {
            connectWebSocket();
            loadElementsState();
            mainCanvasWrapper.style.transformOrigin = 'center center';
            deselectAllElements(); 
            updateLayersList();
            updateAudioPlaylistDisplay();
            updateFileCountDisplay();
            applyZoom();
            showMutePreferenceModal();
        });

        function showMutePreferenceModal() {
            mutePreferenceModal.classList.add('active');

            modalMuteBtn.onclick = () => {
                isMutedGlobally = true;
                applyGlobalMuteState();
                mutePreferenceModal.classList.remove('active');
            };

            modalSoundBtn.onclick = () => {
                isMutedGlobally = false;
                applyGlobalMuteState();
                mutePreferenceModal.classList.remove('active');
            };
        }
    </script>
</body>
</html>
